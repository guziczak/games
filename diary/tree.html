<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drzewko Wyborów</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #333;
            overflow: hidden; /* Prevent overall body scrolling */
        }

        .container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 350px; /* Increased width from 300px to 350px */
            background: #fff;
            border-right: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Make the entire sidebar scrollable */
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
        }

        .main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 0;
            z-index: 20;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            color: #374151;
        }

        .travel-selector {
            padding: 10px 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 60px;
            z-index: 19;
        }

        .travel-selector h3 {
            margin: 0 0 10px 0;
            font-size: 1rem;
            color: #4b5563;
        }

        .travel-option {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: #f3f4f6;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .travel-option:hover {
            background: #e5e7eb;
        }

        .travel-option.active {
            background: #d1d5db;
            font-weight: 600;
        }

        .controls {
            padding: 10px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 130px;
            z-index: 18;
        }

        button {
            padding: 8px 12px;
            background: #4b5563;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        button:hover {
            background: #374151;
        }

        button.active {
            background: #1f2937;
        }

        .layout-options {
            display: flex;
            padding: 10px 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 180px;
            z-index: 17;
        }

        .layout-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .layout-option:hover {
            background: #f3f4f6;
        }

        .layout-option.active {
            background: #e5e7eb;
            font-weight: bold;
        }

        .search-box {
            padding: 10px 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 230px;
            z-index: 16;
        }

        .search-box input {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .scene-info-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: auto; /* Make this container scrollable */
            margin-bottom: 10px; /* Space between info and statistics */
            min-height: 400px; /* Set minimum height */
            max-height: calc(100vh - 330px); /* Ensure there's room for the stats */
        }

        .scene-info {
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .scene-info h3 {
            margin-top: 0;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 10px;
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
        }

        .quote {
            font-style: italic;
            color: #6b7280;
            margin: 15px 0;
            padding: 10px;
            background: #f3f4f6;
            border-left: 4px solid #9ca3af;
            border-radius: 0 4px 4px 0;
        }

        .text {
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .choices {
            margin-top: 20px;
            margin-bottom: 20px; /* Added margin bottom */
            padding-bottom: 10px; /* Extra padding at bottom */
        }

        .choices h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #4b5563;
        }

        .choice-item {
            margin-bottom: 10px;
            padding: 10px;
            background: #f3f4f6;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid #9ca3af;
        }

        .choice-item:hover {
            background: #e5e7eb;
        }

        .statistics {
            padding: 15px 20px;
            background: #f3f4f6;
            border-top: 1px solid #e5e7eb;
            font-size: 0.9rem;
            flex-shrink: 0; /* Prevent statistics from shrinking */
            position: sticky;
            bottom: 0;
            z-index: 15;
        }

        .statistics h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1rem;
            color: #374151;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        /* Status ładowania */
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            text-align: center;
            z-index: 9999;
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid #3b82f6;
            width: 30px;
            height: 30px;
            margin: 0 auto 10px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Stylowanie grafu */
        #visualization {
            width: 100%;
            height: 100%;
            background: #fff;
        }

        .node circle {
            stroke-width: 2px;
        }

        .link {
            fill: none;
            stroke-width: 1.5px;
            stroke: #d1d5db;
        }

        /* Cross-path styling */
        .link.cross-path, .cross-path-connection {
            stroke-dasharray: 8, 4;
            stroke: #ff5500;
            stroke-width: 3px;
            stroke-opacity: 1;
            pointer-events: all; /* Enable interactions with the line */
            cursor: pointer; /* Show pointer cursor */
        }

        /* Cross-path arrow styling */
        .cross-path-arrow {
            fill: #ff5500;
            stroke: none;
        }

        /* Custom tooltip styles */
        .tooltip {
            position: fixed; /* Use fixed instead of absolute */
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.2);
            width: 280px; /* Fixed width */
            z-index: 9999;
            pointer-events: none;
            box-sizing: border-box;
            max-height: 200px;
            overflow-y: auto;
            opacity: 0;
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .tooltip-quote {
            font-style: italic;
            color: #6b7280;
            margin-top: 5px;
            font-size: 13px;
        }

        .mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: #6b7280;
        }

        /* Etykiety węzłów */
        .node text {
            font-size: 10px;
            font-family: Arial, sans-serif;
            fill: #4b5563;
            text-anchor: middle;
            pointer-events: none;
            dominant-baseline: middle;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px;
        }

        .label-background {
            fill: rgba(255, 255, 255, 0.8);
            rx: 3;
            ry: 3;
        }

        /* Dead end node styling */
        .node.dead-end circle {
            stroke: #ef4444;
            stroke-width: 3px;
            filter: drop-shadow(0 0 5px rgba(239, 68, 68, 0.6));
        }

        .node-x {
            stroke: #ef4444;
            stroke-width: 3px;
        }

        /* Pulsing animation for dead end nodes */
        @keyframes pulse-deadend {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .node.dead-end circle {
            animation: pulse-deadend 2s infinite ease-in-out;
        }

        /* Node selection styling */
        .node.selected circle {
            stroke: #000;
            stroke-width: 3px;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.3));
        }

        /* Node hover styling */
        .node.hover circle {
            filter: drop-shadow(0 0 4px rgba(0,0,0,0.2));
        }

        /* Additional transition effects */
        .node circle, .link {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="sidebar">
        <div class="header">
            <h1 id="travelTitle">Drzewko Wyborów</h1>
        </div>

        <div class="travel-selector">
            <h3>Wybierz podróż:</h3>
            <div id="travel-options"></div>
        </div>

        <div class="controls">
            <button id="zoomIn">Powiększ</button>
            <button id="zoomOut">Pomniejsz</button>
            <button id="resetView">Reset widoku</button>
            <button id="focusIntro">Początek</button>
        </div>

        <div class="layout-options">
            <div class="layout-option active" data-layout="tree">Drzewo</div>
            <div class="layout-option" data-layout="cluster">Klaster</div>
            <div class="layout-option" data-layout="radial">Radialny</div>
        </div>

        <div class="search-box">
            <input type="text" id="searchInput" placeholder="Szukaj sceny...">
        </div>

        <div class="scene-info-container">
            <div class="scene-info">
                <h3>Wybierz scenę, aby zobaczyć szczegóły</h3>
                <p>Kliknij węzeł na grafie, aby wyświetlić informacje o danej scenie.</p>
            </div>
        </div>

        <div class="statistics">
            <h3>Statystyki</h3>
            <div class="stat-item">
                <span>Łączna liczba scen:</span>
                <span id="totalScenes">0</span>
            </div>
            <div class="stat-item">
                <span>Liczba wyborów:</span>
                <span id="totalChoices">0</span>
            </div>
            <div class="stat-item">
                <span>Sceny końcowe:</span>
                <span id="endScenes">0</span>
            </div>
            <div class="stat-item">
                <span>Martwe końce:</span>
                <span id="deadEnds">0</span>
            </div>
            <div class="stat-item">
                <span>Połączenia między ścieżkami:</span>
                <span id="crossPathLinks">0</span>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="visualization"></div>
        <div class="tooltip" id="tooltip">
            <div class="tooltip-title"></div>
            <div class="tooltip-quote"></div>
        </div>
        <div class="mode-indicator">Tryb: Drzewo</div>
        <div class="loading-indicator" id="loadingIndicator" style="display: none;">
            <div class="loading-spinner"></div>
            <p>Ładowanie danych...</p>
        </div>
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<!-- Add script to load travels configuration -->
<script src="travels.js"></script>
<script>
    // Globalne zmienne
    let svg, g;
    let zoom;
    let root;
    let width, height;
    let nodeRadius = 8;
    let tooltip;
    let currentLayout = 'tree';
    let labelMode = 'tooltip'; // 'tooltip', 'visible', 'hover'
    let selectedNode = null;
    let currentTravelId = 1; // Domyślnie pierwsza podróż
    let scenesData = {}; // Dane wszystkich scen
    let crossPathLinks = []; // Lista połączeń między ścieżkami

    // Kolory dla różnych typów węzłów
    const nodeColors = {
        'start': '#ef4444',  // czerwony
        'normal': '#3b82f6', // niebieski
        'end': '#22c55e',    // zielony
        'deadEnd': '#f97316' // pomarańczowy dla martwych końców
    };

    // Inicjalizacja wizualizacji
    function initVisualization() {
        const container = document.getElementById('visualization');
        width = container.clientWidth;
        height = container.clientHeight;

        // Inicjalizacja tooltip
        tooltip = d3.select("#tooltip");

        // Inicjalizacja zoom
        zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        // Tworzymy SVG
        svg = d3.select("#visualization")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .call(zoom);

        // Grupa do której będziemy dodawać elementy
        g = svg.append("g");

        // Inicjalizacja selektora podróży
        initTravelSelector();

        // Dodajemy obsługę przycisków i innych interakcji
        setupInteractions();

        // Ładujemy dane dla domyślnej podróży
        loadTravelData(currentTravelId);
    }

    // Inicjalizacja selektora podróży
    function initTravelSelector() {
        const travelOptionsContainer = document.getElementById('travel-options');
        travelOptionsContainer.innerHTML = ''; // Wyczyść kontener

        // Dodaj opcje podróży
        window.travelsConfig.forEach(travel => {
            const option = document.createElement('div');
            option.className = 'travel-option' + (travel.id === currentTravelId ? ' active' : '');
            option.textContent = travel.name;
            option.setAttribute('data-travel-id', travel.id);

            option.addEventListener('click', function() {
                // Usuń klasę active ze wszystkich opcji
                document.querySelectorAll('.travel-option').forEach(opt => {
                    opt.classList.remove('active');
                });

                // Dodaj klasę active do wybranej opcji
                this.classList.add('active');

                // Załaduj dane dla wybranej podróży
                currentTravelId = parseInt(this.getAttribute('data-travel-id'));
                loadTravelData(currentTravelId);
            });

            travelOptionsContainer.appendChild(option);
        });
    }

    // Ładowanie danych JSON dla wybranej podróży
    async function loadTravelData(travelId) {
        // Pokaż wskaźnik ładowania
        const loadingIndicator = document.getElementById('loadingIndicator');
        loadingIndicator.style.display = 'block';

        try {
            // Make sure travelsConfig exists
            if (!window.travelsConfig || !Array.isArray(window.travelsConfig)) {
                throw new Error("Konfiguracja podróży niedostępna. Upewnij się, że plik travels.js jest poprawnie załadowany.");
            }

            // Znajdź konfigurację podróży
            const travel = window.travelsConfig.find(t => t.id === travelId);
            if (!travel) {
                throw new Error(`Podróż o ID ${travelId} nie została znaleziona.`);
            }

            // Aktualizuj tytuł strony i nagłówek
            document.title = `Drzewko Wyborów - ${travel.name}`;
            document.getElementById('travelTitle').textContent = `Drzewko Wyborów - ${travel.name}`;

            // Resetujemy dane scen
            scenesData = {};

            // Defensive check for travel files
            if (!travel.files || !Array.isArray(travel.files) || travel.files.length === 0) {
                throw new Error(`Brak plików do załadowania dla podróży "${travel.name}"`);
            }

            // Ładujemy wszystkie pliki JSON dla wybranej podróży
            for (const file of travel.files) {
                try {
                    const response = await fetch(`${travel.path}/${file}`);
                    if (!response.ok) {
                        throw new Error(`Błąd ładowania pliku ${file}: ${response.status}`);
                    }

                    // Pobierz tekst i usuń komentarze
                    const text = await response.text();
                    const cleanedText = text.replace(/\/\/.*$/gm, '');

                    try {
                        // Parsuj oczyszczony tekst jako JSON
                        const fileData = JSON.parse(cleanedText);

                        // Dodaj do głównego obiektu scen z prefiksem
                        Object.keys(fileData).forEach(sceneId => {
                            const prefixedSceneId = `travel${travelId}_${sceneId}`;
                            const scene = { ...fileData[sceneId] };

                            // Aktualizacja odniesień w wyborach
                            if (scene.choices && scene.choices.length > 0) {
                                scene.choices = scene.choices.map(choice => {
                                    return {
                                        ...choice,
                                        nextScene: `travel${travelId}_${choice.nextScene}`
                                    };
                                });
                            }

                            scenesData[prefixedSceneId] = scene;
                        });
                    } catch (parseError) {
                        console.error(`Błąd parsowania pliku ${file}:`, parseError);
                        throw new Error(`Błąd parsowania pliku ${file}: ${parseError.message}`);
                    }
                } catch (fetchError) {
                    console.error(`Błąd pobierania pliku ${file}:`, fetchError);
                    throw new Error(`Błąd pobierania pliku ${file}: ${fetchError.message}`);
                }
            }

            // Verify that scenesData has content
            if (Object.keys(scenesData).length === 0) {
                throw new Error("Nie załadowano żadnych danych scen. Sprawdź pliki JSON.");
            }

            // Przetwórz dane i renderuj graf
            root = processData(currentLayout);

            // Wykrywamy martwe końce i połączenia między ścieżkami
            detectDeadEnds(root);
            detectCrossPathLinks(root);

            // Obliczamy statystyki
            calculateStatistics(root);

            // Renderujemy drzewo
            renderGraph();

            // Wyświetlamy informacje o scenie początkowej
            displaySceneInfo(`travel${travelId}_intro`);

            // Zaznaczamy węzeł początkowy jako wybrany
            d3.selectAll(".node").filter(d => d.data.id === `travel${travelId}_intro`).classed("selected", true);

            // Resetujemy widok
            resetView();

            console.log(`Podróż ${travel.name} (ID: ${travelId}) załadowana pomyślnie.`);
        } catch (error) {
            console.error(`Błąd podczas ładowania danych podróży:`, error);
            // Wyświetl informację o błędzie
            const infoPanel = document.querySelector('.scene-info');
            infoPanel.innerHTML = `
            <h3 style="color: #ef4444;">⚠️ Błąd ładowania</h3>
            <div class="quote" style="color: #ef4444; background-color: rgba(239, 68, 68, 0.1); border-left-color: #ef4444;">
                "Nie udało się załadować danych dla wybranej podróży. Sprawdź czy pliki JSON istnieją w podanej ścieżce."
            </div>
            <div class="text" style="margin-top: 15px; padding: 10px; background-color: rgba(239, 68, 68, 0.05); border-radius: 4px;">
                <strong>Błąd:</strong> ${error.message}
            </div>
        `;
        } finally {
            // Ukryj wskaźnik ładowania
            loadingIndicator.style.display = 'none';
        }
    }

    // Bezpośrednie wykrywanie połączeń cross-path
    function checkForCrossPathConnections() {
        console.log("DEBUGGING: Starting direct cross-path connection check");
        crossPathLinks = []; // Reset the array

        // Defensive programming: check if scenesData is properly loaded
        if (!scenesData || Object.keys(scenesData).length === 0) {
            console.error("No scene data available for cross-path detection");
            return;
        }

        // Dla każdej sceny w bieżącej podróży, sprawdź wszystkie wybory
        const travelPrefix = `travel${currentTravelId}_`;

        Object.entries(scenesData).forEach(([sceneId, scene]) => {
            // Sprawdź tylko sceny z bieżącej podróży
            if (!sceneId.startsWith(travelPrefix)) return;

            // Jeśli scena ma wybory
            if (scene.choices && scene.choices.length > 0) {
                scene.choices.forEach(choice => {
                    // Defensive check for choice structure
                    if (!choice || !choice.nextScene) return;

                    const targetId = choice.nextScene;

                    // Jeśli cel to nie scenariusz intro i istnieje w danych
                    if (!targetId.endsWith('_intro') && !sceneId.endsWith('_intro') && scenesData[targetId]) {
                        try {
                            // Try to extract scene numbers safely with error handling
                            const sourceMatch = sceneId.replace(travelPrefix, '').match(/\d+/);
                            const targetMatch = targetId.replace(travelPrefix, '').match(/\d+/);

                            if (!sourceMatch || !targetMatch) return;

                            const sourceNum = parseInt(sourceMatch[0]);
                            const targetNum = parseInt(targetMatch[0]);

                            if (isNaN(sourceNum) || isNaN(targetNum)) return;

                            // Sprawdź czy są sąsiednie - różnica większa niż 1 oznacza przeskok
                            const diff = Math.abs(targetNum - sourceNum);

                            if (diff > 1) {
                                console.log(`DEBUGGING: Znaleziono bezpośrednie cross-path połączenie: ${sceneId} -> ${targetId}, różnica: ${diff}`);

                                // Dodaj do listy z wyrazistymi parametrami do renderowania
                                crossPathLinks.push({
                                    source: sceneId,
                                    target: targetId,
                                    sourcePathId: sceneId,
                                    targetPathId: targetId,
                                    isDirect: true,
                                    difference: diff,
                                    color: "#ff3300",
                                    width: 4,
                                    opacity: 1
                                });
                            }
                        } catch (error) {
                            console.error(`Error processing cross-path from ${sceneId} to ${targetId}:`, error);
                        }
                    }
                });
            }
        });

        console.log(`DEBUGGING: Znaleziono ${crossPathLinks.length} bezpośrednich cross-path połączeń`);
    }

    // Dodaj znacznik strzałki z większą widocznością
    function addArrowMarker() {
        // Usuń poprzedni marker, jeśli istnieje
        svg.select("defs").remove();

        // Dodaj nowy marker
        svg.append("defs").append("marker")
            .attr("id", "end-arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#ff5500");
    }

    // Dodaj tę funkcję do renderowania linii cross-path
    function renderCrossPathLinks() {
        console.log("DEBUGGING: Renderowanie cross-path połączeń");

        // Safety check - if root is not defined or crossPathLinks is empty, return
        if (!root || !crossPathLinks || crossPathLinks.length === 0) {
            console.log("No cross-path links to render or missing root");
            return;
        }

        // Najpierw usuń istniejące połączenia cross-path
        g.selectAll(".cross-path-connection").remove();

        // Renderuj każde połączenie cross-path
        crossPathLinks.forEach((link, index) => {
            try {
                console.log(`DEBUGGING: Renderowanie cross-path ${index+1}: ${link.source} -> ${link.target}`);

                // Znajdź węzły źródłowy i docelowy
                const sourceNode = root.descendants().find(d => d.data.id === link.source);
                const targetNode = root.descendants().find(d => d.data.id === link.target);

                if (!sourceNode || !targetNode) {
                    console.log(`DEBUGGING: Brak węzła ${!sourceNode ? 'źródłowego' : 'docelowego'} dla połączenia ${link.source} -> ${link.target}`);
                    return;
                }

                // Ustal współrzędne punktów
                let sx, sy, tx, ty;

                if (currentLayout === 'radial') {
                    sx = Math.sin(sourceNode.x) * sourceNode.y;
                    sy = -Math.cos(sourceNode.x) * sourceNode.y;
                    tx = Math.sin(targetNode.x) * targetNode.y;
                    ty = -Math.cos(targetNode.x) * targetNode.y;
                } else {
                    sx = sourceNode.y; // W układzie drzewa x i y są zamienione
                    sy = sourceNode.x;
                    tx = targetNode.y;
                    ty = targetNode.x;
                }

                // Narysuj linię
                const line = g.append("path")
                    .attr("class", "cross-path-connection")
                    .attr("d", () => {
                        const path = d3.path();

                        if (currentLayout === 'radial') {
                            // Zakrzywiona linia dla układu radialnego
                            path.moveTo(sx, sy);

                            // Punkt kontrolny
                            const midX = (sx + tx) / 2;
                            const midY = (sy + ty) / 2;
                            const dx = tx - sx;
                            const dy = ty - sy;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const offset = dist * 0.3;

                            // Przesunięcie prostopadłe
                            const nx = -dy / dist * offset;
                            const ny = dx / dist * offset;

                            path.quadraticCurveTo(midX + nx, midY + ny, tx, ty);
                        } else {
                            // Krzywa Beziera dla układu drzewa
                            path.moveTo(sx, sy);

                            const midX = (sx + tx) / 2;
                            path.bezierCurveTo(
                                midX, sy,   // pierwszy punkt kontrolny
                                midX, ty,   // drugi punkt kontrolny
                                tx, ty      // punkt końcowy
                            );
                        }

                        return path.toString();
                    })
                    .attr("fill", "none")
                    .attr("stroke", "#ff5500")
                    .attr("stroke-width", 3)
                    .attr("stroke-dasharray", "8,4")
                    .attr("stroke-opacity", 1)
                    .attr("marker-end", "url(#end-arrow)")
                    .on("mouseover", function() {
                        d3.select(this)
                            .attr("stroke-width", 5)
                            .attr("stroke", "#ff0000");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .attr("stroke-width", 3)
                            .attr("stroke", "#ff5500");
                    })
                    .on("click", function() {
                        // Fokus na węźle docelowym po kliknięciu
                        focusOnScene(link.target);
                        displaySceneInfo(link.target);
                    });

                console.log(`DEBUGGING: Narysowano cross-path linię ${index+1}`);
            } catch (error) {
                console.error(`Error rendering cross-path connection ${index}:`, error);
            }
        });
    }

    // Przetwarzanie danych do formatu hierarchicznego
    function processData(layoutType) {
        // Tworzymy funkcję do identyfikacji węzłów
        const stratify = d3.stratify()
            .id(d => d.id)
            .parentId(d => d.parentId);

        // Przygotowujemy dane
        const flatData = [];
        const processedNodes = new Set();
        const processedEdges = new Set();

        // Najpierw wyszukujemy bezpośrednie połączenia cross-path
        checkForCrossPathConnections();

        // Funkcja pomocnicza do przetwarzania scen
        function processScene(sceneId, parentId = null, depth = 0, pathId = null) {
            // Jeśli nie podano pathId, używamy sceneId jako ID ścieżki
            if (pathId === null) {
                pathId = sceneId;
            }

            // Sprawdzamy, czy scena istnieje
            if (!scenesData[sceneId]) {
                console.warn(`Scena nie znaleziona: ${sceneId}`);

                // Dodajemy informację o martwym końcu
                flatData.push({
                    id: `deadend-${parentId}-${sceneId}`,
                    parentId: parentId,
                    name: sceneId,
                    nodeType: 'deadEnd',
                    depth,
                    isDeadEnd: true,
                    pathId
                });
                return;
            }

            const scene = scenesData[sceneId];

            // Określamy typ sceny
            let nodeType = 'normal';
            if (sceneId.endsWith('_intro')) {
                nodeType = 'start';
            } else if (!scene.choices || scene.choices.length === 0 ||
                (scene.choices.length === 1 && scene.choices[0].nextScene.endsWith('_intro'))) {
                nodeType = 'end';
            }

            // Tworzymy unikalny identyfikator krawędzi
            const edgeId = parentId ? `${parentId}->${sceneId}` : null;

            // Sprawdzamy, czy ta krawędź już została przetworzona
            if (parentId && processedEdges.has(edgeId)) {
                return;
            }

            // Zaznaczamy krawędź jako przetworzoną
            if (edgeId) {
                processedEdges.add(edgeId);
            }

            // Jeśli scena już istnieje i ma rodzica, sprawdzamy czy trzeba dodać wirtualny węzeł
            // lub zapisać informację o połączeniu między ścieżkami
            if (processedNodes.has(sceneId) && parentId) {
                // Pobierz istniejący węzeł
                const existingNode = flatData.find(d => d.id === sceneId);

                // Sprawdź czy węzeł należy do innej ścieżki
                if (existingNode && existingNode.pathId !== pathId) {
                    // Dodaj wirtualny węzeł dla lepszego renderowania
                    const virtualNodeId = `virtual-${parentId}-${sceneId}`;
                    flatData.push({
                        id: virtualNodeId,
                        parentId: parentId,
                        name: sceneId,
                        isVirtual: true,
                        targetScene: sceneId,
                        nodeType,
                        pathId,
                        crossPath: true
                    });
                } else {
                    // Jeśli jest w tej samej ścieżce, dodaj standardowy wirtualny węzeł
                    const virtualNodeId = `virtual-${parentId}-${sceneId}`;
                    flatData.push({
                        id: virtualNodeId,
                        parentId: parentId,
                        name: sceneId,
                        isVirtual: true,
                        targetScene: sceneId,
                        nodeType,
                        pathId
                    });
                }
                return;
            }

            // Dodajemy scenę do przetworzonych
            processedNodes.add(sceneId);

            // Dodajemy węzeł do danych
            flatData.push({
                id: sceneId,
                parentId: parentId,
                name: sceneId,
                scene: scene,
                nodeType,
                depth,
                pathId
            });

            // Przetwarzamy wszystkie wybory
            if (scene.choices && scene.choices.length > 0) {
                scene.choices.forEach((choice, i) => {
                    const nextSceneId = choice.nextScene;
                    // Zapisujemy tekst wyboru
                    flatData.find(d => d.id === sceneId).choices =
                        flatData.find(d => d.id === sceneId).choices || [];
                    flatData.find(d => d.id === sceneId).choices[i] = choice.text;

                    // Przetwarzamy następną scenę
                    processScene(nextSceneId, sceneId, depth + 1, pathId);
                });
            }
        }

        // Zaczynamy od sceny "intro" dla aktualnej podróży
        processScene(`travel${currentTravelId}_intro`);

        // Tworzymy hierarchię
        const hierarchy = stratify(flatData);

        // Wybieramy odpowiedni layout
        let layout;
        switch (layoutType) {
            case 'tree':
                layout = d3.tree().size([height - 80, width - 100]);
                break;
            case 'cluster':
                layout = d3.cluster().size([height - 80, width - 100]);
                break;
            case 'radial':
                // Dla układu radialnego używamy mniejszy promień, aby zmieścić graf
                const radius = Math.min(width, height) / 2 - 80;
                layout = d3.cluster()
                    .size([2 * Math.PI, radius])
                    .separation((a, b) => (a.parent == b.parent ? 1 : 2) / a.depth);
                break;
            default:
                layout = d3.tree().size([height - 80, width - 100]);
        }

        // Aplikujemy układ do hierarchii
        return layout(hierarchy);
    }

    // Wykrywanie martwych końców
    function detectDeadEnds(root) {
        let deadEnds = [];

        root.eachAfter(node => {
            if (node.data.isDeadEnd) {
                node.data.nodeType = 'deadEnd';
                deadEnds.push(node);

                // Dodajemy dodatkową przestrzeń wokół martwych końców dla lepszej widoczności
                if (node.parent && node.parent.children && node.parent.children.length > 1) {
                    // Znajdujemy indeks bieżącego węzła w dzieciach rodzica
                    const index = node.parent.children.indexOf(node);

                    // Dodajemy małe przesunięcie dla sąsiednich węzłów dla lepszej widoczności
                    if (index > 0) {
                        // Przesuwamy poprzedni węzeł nieco w lewo
                        const prevNode = node.parent.children[index - 1];
                        if (currentLayout === 'radial') {
                            prevNode.x -= 0.1; // Małe przesunięcie kątowe
                        } else {
                            prevNode.x -= 10; // Przesunięcie w pikselach
                        }
                    }

                    if (index < node.parent.children.length - 1) {
                        // Przesuwamy następny węzeł nieco w prawo
                        const nextNode = node.parent.children[index + 1];
                        if (currentLayout === 'radial') {
                            nextNode.x += 0.1; // Małe przesunięcie kątowe
                        } else {
                            nextNode.x += 10; // Przesunięcie w pikselach
                        }
                    }
                }
            }
        });

        return deadEnds;
    }

    // Wykrywanie i przygotowanie danych o połączeniach między ścieżkami
    function detectCrossPathLinks(root) {
        console.log("Detecting cross-path links in the tree...");
        console.log(`Currently have ${crossPathLinks.length} cross-path links`);

        // Dodatkowa metoda wykrywania połączeń - sprawdzamy wszystkie węzły drzewa
        root.eachAfter(node => {
            if (node.data.scene && node.data.scene.choices) {
                node.data.scene.choices.forEach(choice => {
                    const targetSceneId = choice.nextScene;

                    // Skip intro scenes
                    if (node.data.id.endsWith('_intro') || targetSceneId.endsWith('_intro')) {
                        return;
                    }

                    // Wyszukaj węzeł docelowy w drzewie
                    const targetInTree = root.descendants().find(d =>
                        d.data.id === targetSceneId ||
                        (d.data.isVirtual && d.data.targetScene === targetSceneId));

                    // Jeśli istnieje w drzewie, ale nie jest bezpośrednim dzieckiem
                    if (targetInTree && !areDirectlyConnected(node, targetInTree)) {
                        // To jest cross-path connection
                        const isAlreadyAdded = crossPathLinks.some(link =>
                            link.source === node.data.id && link.target === targetSceneId);

                        if (!isAlreadyAdded) {
                            console.log(`Found new cross-path from ${node.data.id} to ${targetSceneId}`);
                            crossPathLinks.push({
                                source: node.data.id,
                                target: targetSceneId,
                                sourcePathId: node.data.pathId,
                                targetPathId: targetInTree.data.pathId,
                                isDirect: true,
                                fromDetectFunction: true
                            });
                        }
                    }
                });
            }
        });

        // Funkcja sprawdzająca czy dwa węzły są bezpośrednio połączone
        function areDirectlyConnected(parentNode, childNode) {
            if (!parentNode.children) return false;
            return parentNode.children.some(child => child === childNode);
        }

        // Aktualizacja licznika w statystykach
        document.getElementById('crossPathLinks').textContent = crossPathLinks.length;
        console.log(`Total cross-path links after detection: ${crossPathLinks.length}`);
    }

    // Renderowanie grafu
    function renderGraph() {
        // Najpierw czyścimy poprzedni graf
        g.selectAll("*").remove();

        // Dodaj strzałki dla połączeń cross-path
        addArrowMarker();

        console.log(`Rendering graph with ${crossPathLinks.length} cross-path connections`);
        crossPathLinks.forEach(link => {
            console.log(`Cross-path: ${link.source} -> ${link.target}`);
        });

        // Ustawiamy odpowiednie transformacje dla różnych layoutów
        if (currentLayout === 'radial') {
            g.attr("transform", `translate(${width/2},${height/2})`);
        } else {
            g.attr("transform", `translate(50,40)`);
        }

        // Funkcja link generator zależna od typu layoutu
        let linkGenerator;
        if (currentLayout === 'radial') {
            linkGenerator = d3.linkRadial()
                .angle(d => d.x)
                .radius(d => d.y);
        } else {
            linkGenerator = d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x);
        }

        // Rysujemy krawędzie
        g.selectAll(".link")
            .data(root.links())
            .enter()
            .append("path")
            .attr("class", "link")
            .attr("d", linkGenerator);

        // Rysujemy węzły
        const nodes = g.selectAll(".node")
            .data(root.descendants())
            .enter()
            .append("g")
            .attr("class", d => {
                let classes = "node";
                if (d.data.isDeadEnd) classes += " dead-end";
                return classes;
            })
            .attr("transform", d => {
                if (currentLayout === 'radial') {
                    const x = Math.sin(d.x) * d.y;
                    const y = -Math.cos(d.x) * d.y;
                    return `translate(${x},${y})`;
                } else {
                    return `translate(${d.y},${d.x})`;
                }
            })
            .on("click", function(event, d) {
                // Wyczyść poprzednie zaznaczenie
                d3.selectAll(".node").classed("selected", false);

                // Zaznacz bieżący węzeł
                d3.select(this).classed("selected", true);
                selectedNode = d;

                const sceneId = d.data.isVirtual ? d.data.targetScene : d.data.id;
                displaySceneInfo(sceneId);
            })
            .on("mouseover", function(event, d) {
                // Zatrzymaj propagację wydarzeń, aby zapobiec błędnej detekcji
                event.stopPropagation();

                // Dodaj klasę hover
                d3.select(this).classed("hover", true);

                // Podświetlamy węzeł
                d3.select(this).select("circle")
                    .transition().duration(200)
                    .attr("r", nodeRadius * 1.3);

                // Pokazujemy tooltip bez opóźnienia
                showTooltip(event, d);

                // Jeśli etykiety są w trybie "hover", pokazujemy etykietę
                if (labelMode === 'hover') {
                    d3.select(this).select("text").style("opacity", 1);
                }
            })
            .on("mouseout", function() {
                // Usuń klasę hover
                d3.select(this).classed("hover", false);

                // Przywracamy normalny rozmiar węzła
                d3.select(this).select("circle")
                    .transition().duration(200)
                    .attr("r", nodeRadius);

                // Ukrywamy tooltip natychmiast
                tooltip.style("opacity", 0);

                // Jeśli etykiety są w trybie "hover", ukrywamy etykietę
                if (labelMode === 'hover') {
                    d3.select(this).select("text").style("opacity", 0);
                }
            });

        // Dodajemy kółka reprezentujące węzły
        nodes.append("circle")
            .attr("r", nodeRadius)
            .attr("fill", d => {
                if (d.data.isDeadEnd) return nodeColors.deadEnd;

                const sceneId = d.data.isVirtual ? d.data.targetScene : d.data.id;
                const nodeType = d.data.nodeType;
                return nodeColors[nodeType];
            })
            .attr("stroke", d => {
                return d.data.isDeadEnd ? "#ef4444" : "#d1d5db";
            })
            .attr("stroke-width", d => {
                return d.data.isDeadEnd ? 3 : 2;
            });

        // Dodajemy znak X dla martwych końców
        nodes.filter(d => d.data.isDeadEnd)
            .append("g")
            .attr("class", "node-x")
            .call(g => {
                // Dodajemy ciemniejsze tło dla lepszego kontrastu
                g.append("circle")
                    .attr("r", nodeRadius * 0.9)
                    .attr("fill", "#fff")
                    .attr("stroke", "#ef4444")
                    .attr("stroke-width", 1);

                // Linia X - lewa góra do prawego dołu
                g.append("line")
                    .attr("x1", -nodeRadius/1.2)
                    .attr("y1", -nodeRadius/1.2)
                    .attr("x2", nodeRadius/1.2)
                    .attr("y2", nodeRadius/1.2)
                    .attr("stroke", "#ef4444")
                    .attr("stroke-width", 3)
                    .attr("stroke-linecap", "round");

                // Linia X - prawa góra do lewego dołu
                g.append("line")
                    .attr("x1", nodeRadius/1.2)
                    .attr("y1", -nodeRadius/1.2)
                    .attr("x2", -nodeRadius/1.2)
                    .attr("y2", nodeRadius/1.2)
                    .attr("stroke", "#ef4444")
                    .attr("stroke-width", 3)
                    .attr("stroke-linecap", "round");
            });

        // Dodajemy tło dla etykiet (dla lepszej czytelności)
        nodes.append("rect")
            .attr("class", "label-background")
            .attr("x", -25)
            .attr("y", -25)
            .attr("width", 50)
            .attr("height", 20)
            .attr("opacity", 0);  // Domyślnie niewidoczne

        // Dodajemy etykiety węzłów
        nodes.append("text")
            .attr("dy", -15)
            .attr("x", 0)
            .text(d => {
                let name;
                if (d.data.isDeadEnd) {
                    return "Brak sceny!";
                } else {
                    name = d.data.isVirtual ? d.data.targetScene : d.data.id;
                    // Usuń prefix podróży dla czytelności
                    name = name.replace(/^travel\d+_/, '');
                }
                return name.length > 10 ? name.substring(0, 8) + '..' : name;
            })
            .style("opacity", labelMode === 'visible' ? 1 : 0);  // Widoczne tylko w trybie "visible"

        // Aktualizujemy wskaźnik trybu
        document.querySelector('.mode-indicator').textContent = `Tryb: ${
            currentLayout.charAt(0).toUpperCase() + currentLayout.slice(1)
        }`;

        // Renderuj połączenia cross-path
        renderCrossPathLinks();
    }

    // Całkowicie przepisana funkcja wyświetlania tooltipa
    function showTooltip(event, d) {
        // Podstawowe informacje o scenie
        const sceneId = d.data.isVirtual ? d.data.targetScene : d.data.id;
        const scene = d.data.isDeadEnd ? null : scenesData[sceneId];

        // Ustawienie treści tooltipa
        let title = d.data.isDeadEnd ? "Brak sceny!" : sceneId.replace(/^travel\d+_/, '');
        tooltip.select(".tooltip-title").text(title);

        if (d.data.isDeadEnd) {
            tooltip.select(".tooltip-quote").text("Ta ścieżka prowadzi do nieistniejącej sceny.")
                .style("display", "block")
                .style("color", "#ef4444");
        } else if (scene && scene.quote) {
            tooltip.select(".tooltip-quote").text(`"${scene.quote}"`)
                .style("display", "block")
                .style("color", "#6b7280");
        } else {
            tooltip.select(".tooltip-quote").style("display", "none");
        }

        // Pobieramy pozycję kursora
        const mouseX = event.clientX;
        const mouseY = event.clientY;

        // Stała szerokość tooltipa
        const tooltipWidth = 280;

        // Granice widocznego obszaru okna
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Domyślne położenie - po prawej stronie kursora
        let xPos = mouseX + 10;
        let yPos = mouseY + 10;

        // Sprawdzamy czy tooltip wyjdzie poza prawą krawędź
        if (xPos + tooltipWidth > viewportWidth) {
            xPos = Math.max(0, mouseX - tooltipWidth - 10); // umieść po lewej stronie kursora
        }

        // Sprawdzamy czy tooltip wyjdzie poza dolną krawędź
        // Najpierw ustawiamy tooltip, aby poznać jego wysokość
        tooltip.style("left", "0px").style("top", "0px").style("opacity", "0");
        const tooltipHeight = tooltip.node().getBoundingClientRect().height;

        if (yPos + tooltipHeight > viewportHeight) {
            yPos = Math.max(0, mouseY - tooltipHeight - 10); // umieść nad kursorem
        }

        // Ustawiamy tooltip w finalnej pozycji
        tooltip
            .style("left", xPos + "px")
            .style("top", yPos + "px")
            .style("opacity", 1);
    }

    // Wyświetlanie informacji o scenie
    function displaySceneInfo(sceneId) {
        const scene = scenesData[sceneId];
        if (!scene) {
            // Obsługa martwego końca lub nieistniejącej sceny
            const infoPanel = document.querySelector('.scene-info');
            infoPanel.innerHTML = `
                <h3 style="color: #ef4444;">⚠️ Brak sceny: ${sceneId.replace(/^travel\d+_/, '')}</h3>
                <div class="quote" style="color: #ef4444; background-color: rgba(239, 68, 68, 0.1); border-left-color: #ef4444;">
                    "Ta scena nie istnieje w bazie danych. To martwy koniec w drzewie wyborów."
                </div>
                <div class="text" style="margin-top: 15px; padding: 10px; background-color: rgba(239, 68, 68, 0.05); border-radius: 4px;">
                    <strong>Problem:</strong> Ta ścieżka prowadzi do nieistniejącej sceny.<br><br>
                    <strong>Rozwiązanie:</strong> Należy dodać tę scenę do pliku JSON lub poprawić referencję do niej.
                </div>
            `;
            return;
        }

        const infoPanel = document.querySelector('.scene-info');
        const sceneName = sceneId.replace(/^travel\d+_/, '');

        let html = `<h3>Scena: ${sceneName}</h3>`;

        if (scene.quote) {
            html += `<div class="quote">"${scene.quote}"</div>`;
        }

        if (scene.text) {
            // Pokazujemy pełny tekst, pozwalając na scroll
            const textWithoutTags = scene.text.replace(/<\/?[^>]+(>|$)/g, "");
            html += `<div class="text">${textWithoutTags}</div>`;
        }

        if (scene.choices && scene.choices.length > 0) {
            html += `<div class="choices"><h4>Wybory:</h4>`;
            scene.choices.forEach(choice => {
                // Usuwamy prefix podróży dla czytelności
                const nextScene = choice.nextScene.replace(/^travel\d+_/, '');
                html += `<div class="choice-item" data-scene="${choice.nextScene}">${choice.text} → <strong>${nextScene}</strong></div>`;
            });
            html += `</div>`;
        } else {
            html += `<div><em>Scena końcowa lub powrót do początku</em></div>`;
        }

        infoPanel.innerHTML = html;

        // Przewijanie do początku panelu informacyjnego
        const infoContainer = document.querySelector('.scene-info-container');
        infoContainer.scrollTop = 0;

        // Obsługa kliknięcia na wybory
        document.querySelectorAll('.choice-item').forEach(item => {
            item.addEventListener('click', function() {
                const nextSceneId = this.getAttribute('data-scene');
                focusOnScene(nextSceneId);
                displaySceneInfo(nextSceneId);
            });
        });
    }

    // Fokusowanie na konkretnej scenie
    function focusOnScene(sceneId) {
        // Najpierw szukamy węzła bezpośrednio o danym id
        let node = root.descendants().find(d => d.data.id === sceneId);

        // Jeśli nie znaleziono bezpośrednio, szukamy wirtualnych węzłów wskazujących na tę scenę
        if (!node) {
            node = root.descendants().find(d =>
                d.data.isVirtual && d.data.targetScene === sceneId
            );
        }

        // Jeśli nadal nie znaleziono, szukamy martwych końców związanych z tą sceną
        if (!node) {
            node = root.descendants().find(d =>
                d.data.isDeadEnd && d.data.name === sceneId
            );
        }

        if (node) {
            // Usuń poprzednie zaznaczenie
            d3.selectAll(".node").classed("selected", false);

            // Zaznacz znaleziony węzeł
            d3.selectAll(".node").filter(d => d === node).classed("selected", true);
            selectedNode = node;

            let transform;

            if (currentLayout === 'radial') {
                // Dla układu radialnego
                const x = Math.sin(node.x) * node.y;
                const y = -Math.cos(node.x) * node.y;
                transform = d3.zoomIdentity
                    .translate(width/2 - x, height/2 - y)
                    .scale(1.2);
            } else {
                // Dla układu drzewa i klastra
                transform = d3.zoomIdentity
                    .translate(width/2 - node.y, height/2 - node.x)
                    .scale(1.2);
            }

            svg.transition().duration(750).call(zoom.transform, transform);
        }
    }

    // Obliczanie statystyk
    function calculateStatistics(root) {
        // Unikalne sceny (bez wirtualnych)
        const uniqueScenes = new Set();
        root.descendants().forEach(d => {
            if (!d.data.isVirtual && !d.data.isDeadEnd) {
                uniqueScenes.add(d.data.id);
            }
        });

        const totalScenes = uniqueScenes.size;

        // Liczba wyborów
        let totalChoices = 0;
        Object.values(scenesData).forEach(scene => {
            if (scene.choices) {
                totalChoices += scene.choices.length;
            }
        });

        // Liczba scen końcowych
        const endScenes = root.descendants()
            .filter(d => !d.data.isVirtual && !d.data.isDeadEnd && d.data.nodeType === 'end')
            .length;

        // Liczba martwych końców
        const deadEnds = root.descendants()
            .filter(d => d.data.isDeadEnd)
            .length;

        // Liczba połączeń między ścieżkami
        const crossPathsCount = crossPathLinks.length;

        // Aktualizujemy statystyki w interfejsie
        document.getElementById('totalScenes').textContent = totalScenes;
        document.getElementById('totalChoices').textContent = totalChoices;
        document.getElementById('endScenes').textContent = endScenes;
        document.getElementById('deadEnds').textContent = deadEnds;
        document.getElementById('crossPathLinks').textContent = crossPathsCount;
    }

    // Konfiguracja interakcji
    function setupInteractions() {
        // Przycisk powiększania
        document.getElementById('zoomIn').addEventListener('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 1.3);
        });

        // Przycisk pomniejszania
        document.getElementById('zoomOut').addEventListener('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 0.7);
        });

        // Przycisk resetowania widoku
        document.getElementById('resetView').addEventListener('click', resetView);

        // Przycisk powrotu do początku
        document.getElementById('focusIntro').addEventListener('click', () => {
            focusOnScene(`travel${currentTravelId}_intro`);
            displaySceneInfo(`travel${currentTravelId}_intro`);
        });

        // Obsługa wyszukiwania
        document.getElementById('searchInput').addEventListener('input', function() {
            const query = this.value.toLowerCase();
            if (query.length < 2) {
                // Przywracamy normalny widok
                d3.selectAll(".node circle")
                    .attr("r", nodeRadius)
                    .attr("opacity", 1);
                return;
            }

            // Wyszukujemy pasujące węzły
            const nodes = d3.selectAll(".node");
            nodes.each(function(d) {
                const sceneName = d.data.id.replace(/^travel\d+_/, '').toLowerCase();
                const isMatch = sceneName.includes(query);

                // Podświetlamy pasujące węzły
                d3.select(this).select("circle")
                    .transition()
                    .duration(300)
                    .attr("r", isMatch ? nodeRadius * 1.5 : nodeRadius)
                    .attr("opacity", isMatch ? 1 : 0.3);
            });

            // Znajdujemy pierwszy pasujący węzeł
            const matchingNode = root.descendants().find(d =>
                d.data.id.replace(/^travel\d+_/, '').toLowerCase().includes(query)
            );

            if (matchingNode) {
                focusOnScene(matchingNode.data.id);
            }
        });

        // Obsługa zmiany layoutu
        document.querySelectorAll('.layout-option').forEach(option => {
            option.addEventListener('click', function() {
                // Usuwamy klasę active z wszystkich opcji
                document.querySelectorAll('.layout-option').forEach(o => {
                    o.classList.remove('active');
                });

                // Dodajemy klasę active do wybranej opcji
                this.classList.add('active');

                // Zmieniamy layout
                currentLayout = this.getAttribute('data-layout');

                // Przetwarzamy dane na nowo z nowym layoutem
                root = processData(currentLayout);

                // Wykrywamy martwe końce i połączenia między ścieżkami
                detectDeadEnds(root);
                detectCrossPathLinks(root);

                // Renderujemy graf na nowo
                renderGraph();

                // Resetujemy widok
                resetView();
            });
        });

        // Obsługa podwójnego kliknięcia na węzeł (przełączanie etykiet)
        svg.on("dblclick", function(event) {
            // Zatrzymujemy domyślne zachowanie (zoom)
            if (event) event.preventDefault();

            // Zmieniamy tryb etykiet
            if (labelMode === 'tooltip') {
                labelMode = 'visible';
                d3.selectAll(".node text").style("opacity", 1);
                d3.selectAll(".label-background").style("opacity", 0.7);
            } else if (labelMode === 'visible') {
                labelMode = 'hover';
                d3.selectAll(".node text").style("opacity", 0);
                d3.selectAll(".label-background").style("opacity", 0);
            } else {
                labelMode = 'tooltip';
                d3.selectAll(".node text").style("opacity", 0);
                d3.selectAll(".label-background").style("opacity", 0);
            }
        });

        // Obsługa klawiatury - strzałki do nawigacji
        document.addEventListener('keydown', function(event) {
            if (!selectedNode) return;

            let nextNode = null;

            // Znajdź sąsiednie węzły
            if (event.key === 'ArrowUp') {
                // Znajdź poprzedni węzeł (rodzic)
                nextNode = selectedNode.parent;
            } else if (event.key === 'ArrowDown') {
                // Znajdź pierwszy węzeł dziecko
                nextNode = selectedNode.children ? selectedNode.children[0] : null;
            } else if (event.key === 'ArrowLeft') {
                // Znajdź poprzedni węzeł na tym samym poziomie
                if (selectedNode.parent) {
                    const siblings = selectedNode.parent.children;
                    const currentIndex = siblings.indexOf(selectedNode);
                    if (currentIndex > 0) {
                        nextNode = siblings[currentIndex - 1];
                    }
                }
            } else if (event.key === 'ArrowRight') {
                // Znajdź następny węzeł na tym samym poziomie
                if (selectedNode.parent) {
                    const siblings = selectedNode.parent.children;
                    const currentIndex = siblings.indexOf(selectedNode);
                    if (currentIndex < siblings.length - 1) {
                        nextNode = siblings[currentIndex + 1];
                    }
                }
            }

            if (nextNode) {
                // Zaznacz nowy węzeł
                d3.selectAll(".node").classed("selected", false);
                d3.selectAll(".node").filter(d => d === nextNode).classed("selected", true);
                selectedNode = nextNode;

                // Pokaż informacje o scenie
                const sceneId = nextNode.data.isVirtual ? nextNode.data.targetScene : nextNode.data.id;
                displaySceneInfo(sceneId);

                // Przewiń widok do nowego węzła
                focusOnScene(sceneId);

                // Zapobiegaj domyślnej akcji przeglądarki (przewijanie strony)
                event.preventDefault();
            }
        });
    }

    // Resetowanie widoku
    function resetView() {
        if (currentLayout === 'radial') {
            // Dla układu radialnego, centrujemy graf
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(width/2, height/2)
                    .scale(0.9));
        } else {
            // Dla innych układów
            const bounds = g.node().getBBox();
            const fullWidth = bounds.width + 100;
            const fullHeight = bounds.height + 80;

            const scale = 0.9 / Math.max(fullWidth / width, fullHeight / height);
            const translateX = width / 2 - scale * (bounds.x + fullWidth / 2);
            const translateY = height / 2 - scale * (bounds.y + fullHeight / 2);

            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale));
        }
    }

    // Inicjalizacja po załadowaniu strony
    window.addEventListener('DOMContentLoaded', () => {
        initVisualization();
    });
</script>
</body>
</html>