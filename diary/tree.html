<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drzewko Wyborów</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #333;
            overflow: hidden; /* Prevent overall body scrolling */
        }

        .container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 350px; /* Increased width from 300px to 350px */
            background: #fff;
            border-right: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Make the entire sidebar scrollable */
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
        }

        .main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 0;
            z-index: 20;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            color: #374151;
        }

        .travel-selector {
            padding: 10px 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 60px;
            z-index: 19;
            display: none; /* Hide the original travel selector */
        }

        .travel-selector h3 {
            margin: 0 0 10px 0;
            font-size: 1rem;
            color: #4b5563;
        }

        .travel-option {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: #f3f4f6;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .travel-option:hover {
            background: #e5e7eb;
        }

        .travel-option.active {
            background: #d1d5db;
            font-weight: 600;
        }

        .controls {
            padding: 10px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 60px; /* Adjusted due to removal of travel selector */
            z-index: 18;
        }

        button {
            padding: 8px 12px;
            background: #4b5563;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        button:hover {
            background: #374151;
        }

        button.active {
            background: #1f2937;
        }

        /* Nowy styl dla przycisku z fioletowym tłem */
        button.purple {
            background: #6366f1;
        }

        button.purple:hover {
            background: #4f46e5;
        }

        button.purple.active {
            background: #4338ca;
        }

        .layout-options {
            display: flex;
            padding: 10px 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 110px; /* Adjusted due to removal of travel selector */
            z-index: 17;
        }

        .layout-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .layout-option:hover {
            background: #f3f4f6;
        }

        .layout-option.active {
            background: #e5e7eb;
            font-weight: bold;
        }

        .search-box {
            padding: 10px 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 160px; /* Adjusted due to removal of travel selector */
            z-index: 16;
        }

        .search-box input {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .scene-info-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: auto; /* Make this container scrollable */
            margin-bottom: 10px; /* Space between info and statistics */
            min-height: 400px; /* Set minimum height */
            max-height: calc(100vh - 330px); /* Ensure there's room for the stats */
        }

        .scene-info {
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .scene-info h3 {
            margin-top: 0;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 10px;
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
        }

        .quote {
            font-style: italic;
            color: #6b7280;
            margin: 15px 0;
            padding: 10px;
            background: #f3f4f6;
            border-left: 4px solid #9ca3af;
            border-radius: 0 4px 4px 0;
        }

        .text {
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .choices {
            margin-top: 20px;
            margin-bottom: 20px; /* Added margin bottom */
            padding-bottom: 10px; /* Extra padding at bottom */
        }

        .choices h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #4b5563;
        }

        .choice-item {
            margin-bottom: 10px;
            padding: 10px;
            background: #f3f4f6;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid #9ca3af;
        }

        .choice-item:hover {
            background: #e5e7eb;
        }

        .statistics {
            padding: 15px 20px;
            background: #f3f4f6;
            border-top: 1px solid #e5e7eb;
            font-size: 0.9rem;
            flex-shrink: 0; /* Prevent statistics from shrinking */
            position: sticky;
            bottom: 0;
            z-index: 15;
            display: none; /* Hidden, but still there for data binding */
        }

        .statistics h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1rem;
            color: #374151;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        /* Status ładowania */
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            text-align: center;
            z-index: 9999;
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid #3b82f6;
            width: 30px;
            height: 30px;
            margin: 0 auto 10px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Stylowanie grafu */
        #visualization {
            width: 100%;
            height: 100%;
            background: #fff;
        }

        .node circle {
            stroke-width: 2px;
        }

        .link {
            fill: none;
            stroke-width: 1.5px;
            stroke: #d1d5db;
        }

        /* More subtle cross-path styling */
        .link.cross-path, .cross-path-connection {
            stroke-dasharray: 5, 3;
            stroke: #6366f1; /* Indigo color - less harsh than bright red */
            stroke-width: 1.5px;
            stroke-opacity: 0.8;
            pointer-events: all;
            cursor: pointer;
            fill: none; /* Explicitly set fill to none */
        }

        /* Cross-path arrow styling */
        .cross-path-arrow {
            fill: #6366f1;
            stroke: none;
        }

        /* Floating panels styles */
        #panels-container {
            position: fixed;
            right: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 900;
        }

        .floating-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 12px 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 0.9rem;
            max-width: 250px;
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .panel-title {
            margin: 0 0 8px 0;
            font-size: 1rem;
            color: #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer; /* Make entire header clickable */
        }

        .panel-toggle {
            font-size: 0.8rem;
            color: #6b7280;
        }

        .panel-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
            max-height: 300px; /* Set a maximum height for expanded state */
            overflow-y: auto; /* Add scrolling for overflow content */
        }

        .panel-content.collapsed {
            max-height: 0;
        }

        /* Highlight for cross-path connections */
        .stat-highlight {
            color: #4f46e5;
            font-weight: bold;
        }

        /* Add a badge for cross-path count */
        .cross-path-badge {
            background: #6366f1;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: bold;
            display: inline-block;
            margin-left: 5px;
        }

        /* Updated hover states for crosspath connections */
        .cross-path-connection:hover {
            stroke-width: 2.5px;
            stroke: #4f46e5;
            stroke-opacity: 1;
        }

        /* Nowy styl dla węzłów z cross-path */
        .node-cross-path-indicator {
            fill: none;
            stroke: #6366f1;
            stroke-width: 1.5px;
            stroke-dasharray: 2, 2;
            opacity: 0.8;
        }

        /* Styl dla węzłów typu cross-path podczas najechania */
        .node.has-cross-paths:hover .node-cross-path-indicator {
            stroke-width: 2px;
            opacity: 1;
        }

        /* Custom tooltip styles */
        .tooltip {
            position: fixed; /* Use fixed instead of absolute */
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.2);
            width: 280px; /* Fixed width */
            z-index: 9999;
            pointer-events: none;
            box-sizing: border-box;
            max-height: 200px;
            overflow-y: auto;
            opacity: 0;
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .tooltip-quote {
            font-style: italic;
            color: #6b7280;
            margin-top: 5px;
            font-size: 13px;
        }

        /* Tooltip rozszerzony o informacje o cross-path */
        .tooltip-cross-paths {
            margin-top: 10px;
            border-top: 1px solid #e5e7eb;
            padding-top: 5px;
            font-size: 12px;
            color: #6366f1;
        }

        .mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: #6b7280;
        }

        /* Etykiety węzłów */
        .node text {
            font-size: 10px;
            font-family: Arial, sans-serif;
            fill: #4b5563;
            text-anchor: middle;
            pointer-events: none;
            dominant-baseline: middle;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px;
        }

        .label-background {
            fill: rgba(255, 255, 255, 0.8);
            rx: 3;
            ry: 3;
        }

        /* Dead end node styling */
        .node.dead-end circle {
            stroke: #ef4444;
            stroke-width: 3px;
            filter: drop-shadow(0 0 5px rgba(239, 68, 68, 0.6));
        }

        .node-x {
            stroke: #ef4444;
            stroke-width: 3px;
        }

        /* Pulsing animation for dead end nodes */
        @keyframes pulse-deadend {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .node.dead-end circle {
            animation: pulse-deadend 2s infinite ease-in-out;
        }

        /* Node selection styling */
        .node.selected circle {
            stroke: #000;
            stroke-width: 3px;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.3));
        }

        /* Node hover styling */
        .node.hover circle {
            filter: drop-shadow(0 0 4px rgba(0,0,0,0.2));
        }

        /* Additional transition effects */
        .node circle, .link {
            transition: all 0.3s ease;
        }

        /* Nowa animacja dla połączeń cross-path */
        @keyframes dash {
            to {
                stroke-dashoffset: 16; /* Dostosuj wartość odpowiednio do dasharray */
            }
        }

        .cross-path-connection {
            animation: dash 20s linear infinite;
        }

        /* Nowe style dla statystyk cross-path */
        .cross-path-info {
            margin-top: 10px;
            padding: 8px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 4px;
            border-left: 3px solid #6366f1;
        }

        .cross-path-info-title {
            font-weight: bold;
            color: #4f46e5;
            margin-bottom: 5px;
        }

        /* Styl dla etykiet cross-path */
        .cross-path-label {
            pointer-events: none;
            font-size: 9px;
            fill: #6366f1;
            text-anchor: middle;
        }

        /* Efekt hover dla etykiet cross-path */
        .cross-path-connection:hover + .cross-path-label {
            font-weight: bold;
            font-size: 10px;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="sidebar">
        <div class="header">
            <h1 id="travelTitle">Drzewko Wyborów</h1>
        </div>

        <div class="travel-selector">
            <h3>Wybierz podróż:</h3>
            <div id="travel-options"></div>
        </div>

        <div class="controls">
            <button id="zoomIn">Powiększ</button>
            <button id="zoomOut">Pomniejsz</button>
            <button id="resetView">Reset widoku</button>
            <button id="focusIntro">Początek</button>
            <!-- Nowy przycisk do przełączania widoczności cross-path -->
            <button id="toggleCrossPaths" class="purple">Pokaż połączenia</button>
            <!-- Nowy przycisk do podświetlania węzłów z cross-path -->
            <button id="highlightCrossPathNodes" class="purple">Podświetl węzły</button>
        </div>

        <div class="layout-options">
            <div class="layout-option active" data-layout="tree">Drzewo</div>
            <div class="layout-option" data-layout="cluster">Klaster</div>
            <div class="layout-option" data-layout="radial">Radialny</div>
        </div>

        <div class="search-box">
            <input type="text" id="searchInput" placeholder="Szukaj sceny...">
        </div>

        <div class="scene-info-container">
            <div class="scene-info">
                <h3>Wybierz scenę, aby zobaczyć szczegóły</h3>
                <p>Kliknij węzeł na grafie, aby wyświetlić informacje o danej scenie.</p>
            </div>
        </div>

        <!-- Statistics hidden, but kept for data binding -->
        <div class="statistics" style="display: none;">
            <h3>Statystyki</h3>
            <div class="stat-item">
                <span>Łączna liczba scen:</span>
                <span id="totalScenes">0</span>
            </div>
            <div class="stat-item">
                <span>Liczba wyborów:</span>
                <span id="totalChoices">0</span>
            </div>
            <div class="stat-item">
                <span>Sceny końcowe:</span>
                <span id="endScenes">0</span>
            </div>
            <div class="stat-item">
                <span>Martwe końce:</span>
                <span id="deadEnds">0</span>
            </div>
            <div class="stat-item">
                <span>Połączenia między ścieżkami:</span>
                <span id="crossPathLinks">0</span>
            </div>
            <div class="stat-item">
                <span>Przecięcia ścieżek:</span>
                <span id="pathCrossings">0</span>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="visualization"></div>
        <div class="tooltip" id="tooltip">
            <div class="tooltip-title"></div>
            <div class="tooltip-quote"></div>
            <div class="tooltip-cross-paths" style="display: none;"></div>
        </div>
        <div class="mode-indicator">Tryb: Drzewo</div>
        <div class="loading-indicator" id="loadingIndicator" style="display: none;">
            <div class="loading-spinner"></div>
            <p>Ładowanie danych...</p>
        </div>
    </div>
</div>

<!-- Container for floating panels -->
<div id="panels-container"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<!-- Add script to load travels configuration -->
<script src="travels.js"></script>
<script>
    // Globalne zmienne
    let svg, g;
    let zoom;
    let root;
    let width, height;
    let nodeRadius = 8;
    let tooltip;
    let currentLayout = 'tree';
    let labelMode = 'tooltip'; // 'tooltip', 'visible', 'hover'
    let selectedNode = null;
    let currentTravelId = 1; // Domyślnie pierwsza podróż
    let scenesData = {}; // Dane wszystkich scen
    let crossPathLinks = []; // Lista połączeń między ścieżkami
    let showCrossPaths = true; // Domyślnie pokazuj połączenia
    let highlightCrossPathNodes = false; // Domyślnie nie podświetlaj węzłów
    let isAnimatingLayout = false; // Flaga do śledzenia animacji układu

    // Kolory dla różnych typów węzłów
    const nodeColors = {
        'start': '#ef4444',  // czerwony
        'normal': '#3b82f6', // niebieski
        'end': '#22c55e',    // zielony
        'deadEnd': '#f97316' // pomarańczowy dla martwych końców
    };

    // Funkcja grupująca podobne połączenia cross-path
    function groupSimilarCrossPaths(crossPaths) {
        // Mapa do przechowywania grup połączeń
        const groups = new Map();

        // Iterujemy przez wszystkie połączenia
        crossPaths.forEach(link => {
            // Ekstrakcja istotnych części identyfikatorów
            const sourceBase = extractBaseId(link.source);
            const targetBase = extractBaseId(link.target);

            // Tworzenie klucza grupy (wybieramy deterministycznie)
            const groupKey = sourceBase <= targetBase
                ? `${sourceBase}-${targetBase}`
                : `${targetBase}-${sourceBase}`;

            // Dodajemy połączenie do odpowiedniej grupy
            if (!groups.has(groupKey)) {
                groups.set(groupKey, []);
            }
            groups.get(groupKey).push(link);
        });

        // Zwracamy pogrupowane połączenia
        return Array.from(groups.values());
    }

    // Funkcja pomocnicza do wyodrębniania podstawowej części identyfikatora
    function extractBaseId(id) {
        return id.replace(/^travel\d+_/, '').replace(/\d+$/, '');
    }

    // Ulepszona funkcja wykrywania połączeń między ścieżkami
    function detectAllCrossPaths() {
        console.log("Rozpoczynam wykrywanie połączeń między ścieżkami...");
        crossPathLinks = []; // Resetujemy tablicę

        // Sprawdzamy czy dane scen są dostępne
        if (!scenesData || Object.keys(scenesData).length === 0) {
            console.error("Brak dostępnych danych scen dla wykrywania połączeń");
            return;
        }

        const travelPrefix = `travel${currentTravelId}_`;
        const processedConnections = new Set(); // Śledzimy przetwarzane połączenia aby uniknąć duplikatów

        // Budujemy mapę bezpośrednich połączeń hierarchicznych w drzewie
        const directTreeConnections = new Set();
        if (root) {
            root.links().forEach(link => {
                const source = link.source.data.id;
                const target = link.target.data.id;
                directTreeConnections.add(`${source}->${target}`);
            });
        }

        // Budujemy graf wszystkich połączeń z wyborów
        const allConnections = new Map();

        // Wypełniamy graf wszystkimi połączeniami z wyborów
        Object.entries(scenesData).forEach(([sceneId, scene]) => {
            if (!sceneId.startsWith(travelPrefix)) return;

            // Inicjalizujemy węzeł jeśli nie istnieje
            if (!allConnections.has(sceneId)) {
                allConnections.set(sceneId, new Set());
            }

            // Dodajemy wszystkie bezpośrednie połączenia z wyborów
            if (scene.choices) {
                scene.choices.forEach(choice => {
                    if (choice && choice.nextScene && scenesData[choice.nextScene]) {
                        allConnections.get(sceneId).add(choice.nextScene);
                    }
                });
            }
        });

        // UJEDNOLICONA METODA DETEKCJI:
        // 1. Analizujemy wszystkie połączenia z wyborów
        // 2. Jeśli połączenie nie jest częścią hierarchii drzewa, to jest połączeniem między ścieżkami
        allConnections.forEach((targets, sourceId) => {
            // Pomijamy sceny intro
            if (sourceId.endsWith('_intro')) return;

            // Sprawdzamy każde połączenie wychodzące z tego węzła
            targets.forEach(targetId => {
                // Pomijamy sceny intro
                if (targetId.endsWith('_intro')) return;

                const connectionKey = `${sourceId}->${targetId}`;

                // Pomijamy już przetworzone połączenia
                if (processedConnections.has(connectionKey)) return;

                // Jeśli to nie jest standardowe połączenie w hierarchii drzewa, to jest to połączenie między ścieżkami
                if (!directTreeConnections.has(connectionKey)) {
                    // Spróbujmy uzyskać głębszą informację o tym połączeniu
                    let pathDetails = extractPathDetails(sourceId, targetId);

                    // Dodajemy połączenie do przetworzonych
                    processedConnections.add(connectionKey);

                    // Dodajemy do listy połączeń między ścieżkami
                    crossPathLinks.push({
                        source: sourceId,
                        target: targetId,
                        sourcePathId: sourceId,
                        targetPathId: targetId,
                        isDirect: true,
                        method: "unified-detection",
                        ...pathDetails
                    });
                }
            });
        });

        console.log(`Znaleziono ${crossPathLinks.length} połączeń między ścieżkami`);

        // Odfiltrowanie dubli i połączeń do tego samego węzła
        crossPathLinks = crossPathLinks.filter((link, index, self) =>
                link.source !== link.target && // Eliminacja pętli
                index === self.findIndex(l =>
                    (l.source === link.source && l.target === link.target) ||
                    (l.source === link.target && l.target === link.source)
                )
        );

        console.log(`Po usunięciu duplikatów pozostało ${crossPathLinks.length} połączeń`);

        // Aktualizacja statystyk
        updateCrossPathStats(crossPathLinks.length);

        // Aktualizuj listę węzłów z cross-path dla późniejszego podświetlenia
        updateCrossPathNodes();
    }

    // Pomocnicza funkcja do wyodrębniania szczegółów połączenia
    function extractPathDetails(sourceId, targetId) {
        let details = {};

        try {
            // Bezpieczne wyodrębnianie identyfikatorów scen bez założeń o formacie
            const extractSceneId = (id) => {
                // Usuń prefix podróży
                let sceneId = id.replace(/^travel\d+_/, '');
                return sceneId;
            };

            const sourceSceneId = extractSceneId(sourceId);
            const targetSceneId = extractSceneId(targetId);

            details.sourceSceneId = sourceSceneId;
            details.targetSceneId = targetSceneId;

            // Opcjonalne: próba wyodrębnienia liczb dla obliczenia "odległości"
            // Używamy bezpiecznego podejścia, które nie zakłada konkretnego formatu
            try {
                const sourceNumMatch = sourceSceneId.match(/(\d+)/);
                const targetNumMatch = targetSceneId.match(/(\d+)/);

                if (sourceNumMatch && targetNumMatch) {
                    const sourceNum = parseInt(sourceNumMatch[0]);
                    const targetNum = parseInt(targetNumMatch[0]);

                    if (!isNaN(sourceNum) && !isNaN(targetNum)) {
                        details.numericDifference = Math.abs(targetNum - sourceNum);
                    }
                }
            } catch (numError) {
                // Ignorujemy błędy numeracji - to tylko opcjonalna informacja
            }
        } catch (error) {
            console.error("Błąd podczas wyodrębniania szczegółów ścieżki:", error);
        }

        return details;
    }

    // Zbiór wszystkich węzłów, które mają połączenia cross-path
    let crossPathNodes = new Set();

    // Funkcja aktualizująca listę węzłów z cross-path
    function updateCrossPathNodes() {
        crossPathNodes.clear();

        // Dodajemy wszystkie węzły, które mają połączenia cross-path
        crossPathLinks.forEach(link => {
            crossPathNodes.add(link.source);
            crossPathNodes.add(link.target);
        });

        console.log(`Znaleziono ${crossPathNodes.size} węzłów z połączeniami cross-path`);
    }

    // Funkcja do aktualizacji statystyk połączeń między ścieżkami
    function updateCrossPathStats(count) {
        // Aktualizujemy statystyki w interfejsie
        document.getElementById('crossPathLinks').textContent = count;
        document.getElementById('pathCrossings').textContent = count;

        // Aktualizujemy statystyki w panelu, jeśli istnieje
        if (document.getElementById('crossPathLinks-panel')) {
            document.getElementById('crossPathLinks-panel').textContent = count;
            document.getElementById('pathCrossings-panel').textContent = count;
        }
    }

    // Funkcja dodająca marker strzałki dla połączeń między ścieżkami
    function addArrowMarker() {
        // Usunięcie poprzednich markerów
        svg.select("defs").remove();

        // Dodanie nowego markera z delikatniejszym stylem
        const defs = svg.append("defs");

        // Tworzenie markera strzałki końcowej
        defs.append("marker")
            .attr("id", "end-arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 6) // Mniejszy marker
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-4L8,0L0,4") // Nieco mniejsza strzałka
            .attr("fill", "#6366f1") // Kolor indygo pasujący do ścieżki
            .attr("stroke", "none"); // Bez obrysu
    }

    // Ulepszona funkcja renderowania połączeń między ścieżkami
    function renderCrossPathLinks() {
        console.log(`Renderowanie ${crossPathLinks.length} połączeń między ścieżkami`);

        // Zabezpieczenie
        if (!root || !crossPathLinks || crossPathLinks.length === 0) {
            console.log("Brak połączeń między ścieżkami do renderowania lub brak korzenia");
            return;
        }

        // Usuwamy istniejące połączenia między ścieżkami
        g.selectAll(".cross-path-connection").remove();
        g.selectAll(".cross-path-label").remove();

        // Sprawdzenie czy połączenia mają być widoczne
        if (!showCrossPaths) {
            console.log("Połączenia między ścieżkami są ukryte");
            return;
        }

        // Tworzymy mapę dla szybkiego wyszukiwania węzłów
        const nodeMap = new Map();

        // Budujemy mapę wszystkich węzłów (zwykłych)
        root.descendants().forEach(node => {
            // Dodajemy węzeł pod jego własnym ID
            nodeMap.set(node.data.id, node);
        });

        // W drugim kroku dodajemy mapowanie dla węzłów wirtualnych
        // Robimy to osobno, aby uniknąć nadpisywania rzeczywistych węzłów
        root.descendants().forEach(node => {
            if (node.data.isVirtual && node.data.targetScene) {
                // Jeśli nie ma już węzła o tym ID, dodajemy mapowanie wirtualne
                if (!nodeMap.has(node.data.targetScene)) {
                    nodeMap.set(node.data.targetScene, node);
                }
            }
        });

        // Grupujemy podobne połączenia
        const groupedPaths = groupSimilarCrossPaths(crossPathLinks);

        // Renderujemy każdą grupę połączeń
        groupedPaths.forEach((group, groupIndex) => {
            // Dla każdej grupy obliczamy jej środek, aby móc pozycjonować etykietę
            let groupMidpoints = [];

            // Renderujemy każde połączenie w grupie
            group.forEach((link, index) => {
                try {
                    // Pomijamy połączenia z/do intro
                    if (link.source.endsWith('_intro') || link.target.endsWith('_intro')) {
                        return;
                    }

                    // Znajdujemy węzły źródłowy i docelowy
                    const sourceNode = nodeMap.get(link.source);
                    const targetNode = nodeMap.get(link.target);

                    if (!sourceNode || !targetNode) {
                        // Pomijamy to połączenie, jeśli węzły nie zostały znalezione
                        console.log(`Nie znaleziono węzłów dla połączenia: ${link.source} -> ${link.target}`);
                        return;
                    }

                    // Obliczamy współrzędne w zależności od layoutu
                    let sx, sy, tx, ty;
                    let curveIntensity = 0.3; // Domyślna intensywność krzywizny

                    // Obliczamy położenie źródła i celu w zależności od layoutu
                    if (currentLayout === 'radial') {
                        sx = Math.sin(sourceNode.x) * sourceNode.y;
                        sy = -Math.cos(sourceNode.x) * sourceNode.y;
                        tx = Math.sin(targetNode.x) * targetNode.y;
                        ty = -Math.cos(targetNode.x) * targetNode.y;

                        // W układzie radialnym, dostosowujemy krzywiznę w oparciu o odległość kątową
                        const angularDistance = Math.abs(sourceNode.x - targetNode.x);
                        curveIntensity = Math.min(0.5, Math.max(0.1, angularDistance / (Math.PI * 2) * 0.8));
                    } else {
                        sx = sourceNode.y;
                        sy = sourceNode.x;
                        tx = targetNode.y;
                        ty = targetNode.x;

                        // W układzie drzewa, dostosowujemy krzywiznę w oparciu o odległość poziomą i pionową
                        const dx = Math.abs(sx - tx);
                        const dy = Math.abs(sy - ty);

                        if (dx > dy * 3) {
                            // Dla połączeń głównie poziomych, zmniejszamy krzywiznę
                            curveIntensity = 0.2;
                        } else if (dy > dx * 3) {
                            // Dla połączeń głównie pionowych, zwiększamy krzywiznę
                            curveIntensity = 0.4;
                        }
                    }

                    // Obliczamy odległość między punktami
                    const dx = tx - sx;
                    const dy = ty - sy;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Dostosowujemy szerokość linii w zależności od odległości
                    // Dłuższe połączenia mogą być nieco cieńsze dla przejrzystości
                    const lineWidth = Math.max(1, Math.min(2, 2 - distance / 1000));

                    // Dla większej liczby połączeń w grupie, lekko przesuwamy każde z nich
                    // aby uniknąć nakładania się
                    let offsetMultiplier = 0;
                    if (group.length > 1) {
                        offsetMultiplier = (index - (group.length - 1) / 2) * 0.1;
                    }

                    // Tworzymy ścieżkę - teraz z animacją
                    const line = g.append("path")
                        .attr("class", "cross-path-connection")
                        .attr("d", () => {
                            const path = d3.path();

                            if (currentLayout === 'radial') {
                                // Zakrzywiona ścieżka dla układu radialnego
                                path.moveTo(sx, sy);

                                // Obliczamy punkt kontrolny dla krzywizny
                                const midX = (sx + tx) / 2;
                                const midY = (sy + ty) / 2;

                                // Obliczamy przesunięcie prostopadłe dla krzywizny
                                const offset = distance * (curveIntensity + offsetMultiplier);
                                const nx = -dy / distance * offset;
                                const ny = dx / distance * offset;

                                path.quadraticCurveTo(midX + nx, midY + ny, tx, ty);

                                // Zapisujemy punkt środkowy dla etykiety
                                groupMidpoints.push({
                                    x: midX + nx * 0.9,
                                    y: midY + ny * 0.9
                                });
                            } else {
                                // Krzywa Beziera dla układu drzewa
                                path.moveTo(sx, sy);

                                // Dynamiczne punkty kontrolne w zależności od położenia węzłów
                                const midX = (sx + tx) / 2;

                                // Jeśli węzły są na podobnej wysokości, używamy bardziej zakrzywionej ścieżki
                                if (Math.abs(sy - ty) < 50) {
                                    const offset = Math.min(100, distance * (0.3 + offsetMultiplier));
                                    path.bezierCurveTo(
                                        midX, sy - offset,
                                        midX, ty + offset,
                                        tx, ty
                                    );

                                    // Zapisujemy punkt środkowy dla etykiety
                                    groupMidpoints.push({
                                        x: midX,
                                        y: (sy + ty) / 2 - offset / 2
                                    });
                                } else {
                                    // Standardowa krzywa Beziera
                                    path.bezierCurveTo(
                                        midX, sy,
                                        midX, ty,
                                        tx, ty
                                    );

                                    // Zapisujemy punkt środkowy dla etykiety
                                    groupMidpoints.push({
                                        x: midX,
                                        y: (sy + ty) / 2
                                    });
                                }
                            }

                            return path.toString();
                        })
                        .attr("fill", "none") // Jawnie ustawiamy wypełnienie na none
                        .attr("stroke-width", lineWidth) // Dynamiczna szerokość linii
                        .attr("marker-end", "url(#end-arrow)")
                        // Dodajemy animowaną płynną przezroczystość dla płynniejszego wejścia
                        .attr("opacity", 0)
                        .transition()
                        .duration(800)
                        .attr("opacity", 0.8)
                        .on("end", function() {
                            // Po zakończeniu animacji, dodajemy interakcję
                            d3.select(this)
                                .on("click", function() {
                                    focusOnScene(link.target);
                                    displaySceneInfo(link.target);
                                })
                                .on("mouseenter", function() {
                                    d3.select(this)
                                        .transition()
                                        .duration(200)
                                        .attr("stroke-width", lineWidth * 1.5)
                                        .attr("stroke-opacity", 1);
                                })
                                .on("mouseleave", function() {
                                    d3.select(this)
                                        .transition()
                                        .duration(200)
                                        .attr("stroke-width", lineWidth)
                                        .attr("stroke-opacity", 0.8);
                                });
                        });

                    // Dodajemy tooltip z informacją o połączeniu
                    const sourceLabel = link.sourceSceneId || link.source.replace(/^travel\d+_/, '');
                    const targetLabel = link.targetSceneId || link.target.replace(/^travel\d+_/, '');

                    line.append("title")
                        .text(`${sourceLabel} → ${targetLabel}`);
                } catch (error) {
                    console.error(`Błąd renderowania połączenia ${index} w grupie ${groupIndex}:`, error);
                }
            });

            // Jeśli mamy punkty środkowe, dodajemy etykietę dla całej grupy
            if (groupMidpoints.length > 0) {
                // Obliczamy średni punkt środkowy dla wszystkich połączeń w grupie
                const avgX = groupMidpoints.reduce((sum, p) => sum + p.x, 0) / groupMidpoints.length;
                const avgY = groupMidpoints.reduce((sum, p) => sum + p.y, 0) / groupMidpoints.length;

                // Tworzymy reprezentatywną etykietę dla tej grupy połączeń
                const firstLink = group[0];
                const sourceLabel = firstLink.sourceSceneId?.match(/[a-zA-Z]+/)?.[0] || "";
                const targetLabel = firstLink.targetSceneId?.match(/[a-zA-Z]+/)?.[0] || "";

                // Dodajemy etykietę tylko jeśli mamy sensowne wartości
                if (sourceLabel && targetLabel && sourceLabel !== targetLabel) {
                    g.append("text")
                        .attr("class", "cross-path-label")
                        .attr("x", avgX)
                        .attr("y", avgY)
                        .attr("dy", -5)
                        .text(`${sourceLabel}↔${targetLabel}`)
                        .attr("opacity", 0)
                        .transition()
                        .delay(800) // Opóźnienie po animacji linii
                        .duration(400)
                        .attr("opacity", 0.7);
                }
            }
        });

        console.log(`Pomyślnie wyrenderowano ${groupedPaths.length} grup połączeń między ścieżkami`);
    }

    // Funkcja przełączająca widoczność połączeń cross-path
    function toggleCrossPathVisibility() {
        showCrossPaths = !showCrossPaths;

        // Aktualizacja stylu przycisku
        const button = document.getElementById('toggleCrossPaths');
        button.textContent = showCrossPaths ? "Ukryj połączenia" : "Pokaż połączenia";
        button.classList.toggle('active', showCrossPaths);

        // Renderowanie połączeń cross-path w zależności od ich widoczności
        if (showCrossPaths) {
            renderCrossPathLinks();
        } else {
            g.selectAll(".cross-path-connection").remove();
            g.selectAll(".cross-path-label").remove();
        }
    }

    // Funkcja przełączająca podświetlanie węzłów z cross-path
    function toggleHighlightCrossPathNodes() {
        highlightCrossPathNodes = !highlightCrossPathNodes;

        // Aktualizacja stylu przycisku
        const button = document.getElementById('highlightCrossPathNodes');
        button.textContent = highlightCrossPathNodes ? "Ukryj podświetlenie" : "Podświetl węzły";
        button.classList.toggle('active', highlightCrossPathNodes);

        // Aktualizacja podświetlenia węzłów
        updateCrossPathNodesHighlight();
    }

    // Funkcja aktualizująca podświetlenie węzłów z cross-path
    function updateCrossPathNodesHighlight() {
        // Usuwamy istniejące wskaźniki
        g.selectAll(".node-cross-path-indicator").remove();

        // Jeśli podświetlenie jest włączone, dodajemy nowe wskaźniki
        if (highlightCrossPathNodes) {
            // Znajdujemy wszystkie węzły z cross-path
            g.selectAll(".node").each(function(d) {
                const node = d3.select(this);
                const nodeId = d.data.id;

                // Sprawdzamy czy węzeł uczestniczy w połączeniu cross-path
                if (crossPathNodes.has(nodeId)) {
                    // Dodajemy klasę dla stylizacji
                    node.classed("has-cross-paths", true);

                    // Dodajemy wskaźnik cross-path (zewnętrzny pierścień)
                    node.append("circle")
                        .attr("class", "node-cross-path-indicator")
                        .attr("r", nodeRadius * 1.5)
                        .attr("opacity", 0) // Zaczynamy od przezroczystości 0
                        .transition()
                        .duration(400)
                        .attr("opacity", 0.8); // Animacja do pełnej przezroczystości
                }
            });
        } else {
            // Usuwamy klasę ze wszystkich węzłów
            g.selectAll(".node").classed("has-cross-paths", false);
        }
    }

    // Funkcja aktualizująca tooltip o informacje cross-path
    function updateTooltipWithCrossPathInfo(d) {
        const crossPathSection = tooltip.select(".tooltip-cross-paths");
        const nodeId = d.data.isVirtual ? d.data.targetScene : d.data.id;

        // Sprawdzamy czy węzeł ma połączenia cross-path
        if (crossPathNodes.has(nodeId)) {
            // Znajdujemy wszystkie połączenia dla tego węzła
            const connections = crossPathLinks.filter(link =>
                link.source === nodeId || link.target === nodeId
            );

            if (connections.length > 0) {
                // Tworzymy listę połączeń
                let connectionsList = "";
                connections.slice(0, 5).forEach(link => {
                    const isSource = link.source === nodeId;
                    const otherNodeId = isSource ? link.target : link.source;
                    const otherNodeName = otherNodeId.replace(/^travel\d+_/, '');
                    connectionsList += `• ${isSource ? "→" : "←"} ${otherNodeName}<br>`;
                });

                // Jeśli jest więcej połączeń, dodajemy informację o ilości
                if (connections.length > 5) {
                    connectionsList += `• ... i ${connections.length - 5} więcej`;
                }

                // Aktualizujemy zawartość tooltipa
                crossPathSection.html(`
                    <div class="cross-path-info-title">Połączenia (${connections.length}):</div>
                    ${connectionsList}
                `);
                crossPathSection.style("display", "block");
            } else {
                crossPathSection.style("display", "none");
            }
        } else {
            crossPathSection.style("display", "none");
        }
    }

    // Utworzenie panelu informacji o cross-path
    function createCrossPathInfoPanel() {
        // Jeśli panel już istnieje, usuwamy go
        d3.select('.cross-path-panel').remove();

        // Tworzymy panel
        const panel = d3.select('#panels-container')
            .append('div')
            .attr('class', 'floating-panel cross-path-panel')
            .style('border-left', '4px solid #6366f1')
            .html(`
                <h3 class="panel-title">
                    Połączenia między ścieżkami
                    <span class="panel-toggle" id="cross-path-toggle">▼</span>
                </h3>
                <div class="panel-content" id="cross-path-panel-content">
                    <div class="stat-item">
                        <span>Liczba połączeń:</span>
                        <span id="cross-path-count" class="stat-highlight">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Zaangażowane węzły:</span>
                        <span id="cross-path-nodes-count" class="stat-highlight">0</span>
                    </div>
                    <div class="cross-path-info">
                        <div class="cross-path-info-title">Legenda:</div>
                        <div style="margin-top: 5px;">
                            <svg width="100" height="20" style="display: block; margin: 0 auto;">
                                <path d="M5,10 L95,10" stroke="#6366f1" stroke-width="2" stroke-dasharray="5,3"></path>
                                <polygon points="95,10 90,7 90,13" fill="#6366f1"></polygon>
                            </svg>
                            <div style="text-align: center; font-size: 0.8rem; margin-top: 2px;">Połączenie między ścieżkami</div>
                        </div>
                    </div>
                </div>
            `);

        // Aktualizujemy statystyki
        document.getElementById('cross-path-count').textContent = crossPathLinks.length;
        document.getElementById('cross-path-nodes-count').textContent = crossPathNodes.size;

        // Dodajemy interakcję do nagłówka
        panel.select(".panel-title").on("click", function() {
            const content = document.getElementById('cross-path-panel-content');
            const toggle = document.getElementById('cross-path-toggle');

            content.classList.toggle('collapsed');
            toggle.textContent = content.classList.contains('collapsed') ? '▲' : '▼';
        });

        return panel;
    }

    // Inicjalizacja wizualizacji
    function initVisualization() {
        const container = document.getElementById('visualization');
        width = container.clientWidth;
        height = container.clientHeight;

        // Inicjalizacja tooltip
        tooltip = d3.select("#tooltip");

        // Inicjalizacja zoom
        zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        // Tworzymy SVG
        svg = d3.select("#visualization")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .call(zoom);

        // Grupa do której będziemy dodawać elementy
        g = svg.append("g");

        // Dodajemy obsługę przycisków i innych interakcji
        setupInteractions();

        // Create floating panels
        createTravelPanel();
        createStatsPanel();

        // Panel informacji o cross-path zostanie utworzony po wykryciu połączeń

        // Hide the statistics section in the sidebar
        document.querySelector('.statistics').style.display = 'none';

        // Ładujemy dane dla domyślnej podróży
        loadTravelData(currentTravelId);
    }

    // Ładowanie danych JSON dla wybranej podróży
    async function loadTravelData(travelId) {
        // Pokaż wskaźnik ładowania
        const loadingIndicator = document.getElementById('loadingIndicator');
        loadingIndicator.style.display = 'block';

        try {
            // Make sure travelsConfig exists
            if (!window.travelsConfig || !Array.isArray(window.travelsConfig)) {
                throw new Error("Konfiguracja podróży niedostępna. Upewnij się, że plik travels.js jest poprawnie załadowany.");
            }

            // Znajdź konfigurację podróży
            const travel = window.travelsConfig.find(t => t.id === travelId);
            if (!travel) {
                throw new Error(`Podróż o ID ${travelId} nie została znaleziona.`);
            }

            // Aktualizuj tytuł strony i nagłówek
            document.title = `Drzewko Wyborów - ${travel.name}`;
            document.getElementById('travelTitle').textContent = `Drzewko Wyborów - ${travel.name}`;

            // Resetujemy dane scen
            scenesData = {};

            // Resetujemy cross-path
            crossPathLinks = [];
            crossPathNodes.clear();

            // Defensive check for travel files
            if (!travel.files || !Array.isArray(travel.files) || travel.files.length === 0) {
                throw new Error(`Brak plików do załadowania dla podróży "${travel.name}"`);
            }

            // Ładujemy wszystkie pliki JSON dla wybranej podróży
            for (const file of travel.files) {
                try {
                    const response = await fetch(`${travel.path}/${file}`);
                    if (!response.ok) {
                        throw new Error(`Błąd ładowania pliku ${file}: ${response.status}`);
                    }

                    // Pobierz tekst i usuń komentarze
                    const text = await response.text();
                    const cleanedText = text.replace(/\/\/.*$/gm, '');

                    try {
                        // Parsuj oczyszczony tekst jako JSON
                        const fileData = JSON.parse(cleanedText);

                        // Dodaj do głównego obiektu scen z prefiksem
                        Object.keys(fileData).forEach(sceneId => {
                            const prefixedSceneId = `travel${travelId}_${sceneId}`;
                            const scene = { ...fileData[sceneId] };

                            // Aktualizacja odniesień w wyborach
                            if (scene.choices && scene.choices.length > 0) {
                                scene.choices = scene.choices.map(choice => {
                                    return {
                                        ...choice,
                                        nextScene: `travel${travelId}_${choice.nextScene}`
                                    };
                                });
                            }

                            scenesData[prefixedSceneId] = scene;
                        });
                    } catch (parseError) {
                        console.error(`Błąd parsowania pliku ${file}:`, parseError);
                        throw new Error(`Błąd parsowania pliku ${file}: ${parseError.message}`);
                    }
                } catch (fetchError) {
                    console.error(`Błąd pobierania pliku ${file}:`, fetchError);
                    throw new Error(`Błąd pobierania pliku ${file}: ${fetchError.message}`);
                }
            }

            // Verify that scenesData has content
            if (Object.keys(scenesData).length === 0) {
                throw new Error("Nie załadowano żadnych danych scen. Sprawdź pliki JSON.");
            }

            // Przetwórz dane i renderuj graf
            root = processData(currentLayout);

            // Wykrywamy martwe końce
            detectDeadEnds(root);

            // Wykrywamy połączenia między ścieżkami
            detectAllCrossPaths();

            // Tworzymy panel informacji o cross-path
            createCrossPathInfoPanel();

            // Obliczamy statystyki
            calculateStatistics(root);

            // Renderujemy drzewo
            renderGraph();

            // Wyświetlamy informacje o scenie początkowej
            displaySceneInfo(`travel${travelId}_intro`);

            // Zaznaczamy węzeł początkowy jako wybrany
            d3.selectAll(".node").filter(d => d.data.id === `travel${travelId}_intro`).classed("selected", true);

            // Resetujemy widok
            resetView();

            // Update travel options in both panels
            updateTravelSelectors();

            console.log(`Podróż ${travel.name} (ID: ${travelId}) załadowana pomyślnie.`);
        } catch (error) {
            console.error(`Błąd podczas ładowania danych podróży:`, error);
            // Wyświetl informację o błędzie
            const infoPanel = document.querySelector('.scene-info');
            infoPanel.innerHTML = `
                <h3 style="color: #ef4444;">⚠️ Błąd ładowania</h3>
                <div class="quote" style="color: #ef4444; background-color: rgba(239, 68, 68, 0.1); border-left-color: #ef4444;">
                    "Nie udało się załadować danych dla wybranej podróży. Sprawdź czy pliki JSON istnieją w podanej ścieżce."
                </div>
                <div class="text" style="margin-top: 15px; padding: 10px; background-color: rgba(239, 68, 68, 0.05); border-radius: 4px;">
                    <strong>Błąd:</strong> ${error.message}
                </div>
            `;
        } finally {
            // Ukryj wskaźnik ładowania
            loadingIndicator.style.display = 'none';
        }
    }

    // Update travel selectors in both sidebar and floating panel
    function updateTravelSelectors() {
        // Update travel options in floating panel
        const floatingOptions = document.querySelectorAll('#floating-travel-options .travel-option');
        floatingOptions.forEach(option => {
            const travelId = parseInt(option.getAttribute('data-travel-id'));
            if (travelId === currentTravelId) {
                option.classList.add('active');
            } else {
                option.classList.remove('active');
            }
        });
    }

    // Przetwarzanie danych do formatu hierarchicznego
    function processData(layoutType) {
        // Tworzymy funkcję do identyfikacji węzłów
        const stratify = d3.stratify()
            .id(d => d.id)
            .parentId(d => d.parentId);

        // Przygotowujemy dane
        const flatData = [];
        const processedNodes = new Set();
        const processedEdges = new Set();

        // Funkcja pomocnicza do przetwarzania scen
        function processScene(sceneId, parentId = null, depth = 0, pathId = null) {
            // Jeśli nie podano pathId, używamy sceneId jako ID ścieżki
            if (pathId === null) {
                pathId = sceneId;
            }

            // Sprawdzamy, czy scena istnieje
            if (!scenesData[sceneId]) {
                console.warn(`Scena nie znaleziona: ${sceneId}`);

                // Dodajemy informację o martwym końcu
                flatData.push({
                    id: `deadend-${parentId}-${sceneId}`,
                    parentId: parentId,
                    name: sceneId,
                    nodeType: 'deadEnd',
                    depth,
                    isDeadEnd: true,
                    pathId
                });
                return;
            }

            const scene = scenesData[sceneId];

            // Określamy typ sceny
            let nodeType = 'normal';
            if (sceneId.endsWith('_intro')) {
                nodeType = 'start';
            } else if (!scene.choices || scene.choices.length === 0 ||
                (scene.choices.length === 1 && scene.choices[0].nextScene.endsWith('_intro'))) {
                nodeType = 'end';
            }

            // Tworzymy unikalny identyfikator krawędzi
            const edgeId = parentId ? `${parentId}->${sceneId}` : null;

            // Sprawdzamy, czy ta krawędź już została przetworzona
            if (parentId && processedEdges.has(edgeId)) {
                return;
            }

            // Zaznaczamy krawędź jako przetworzoną
            if (edgeId) {
                processedEdges.add(edgeId);
            }

            // Jeśli scena już istnieje i ma rodzica, sprawdzamy czy trzeba dodać wirtualny węzeł
            // lub zapisać informację o połączeniu między ścieżkami
            if (processedNodes.has(sceneId) && parentId) {
                // Pobierz istniejący węzeł
                const existingNode = flatData.find(d => d.id === sceneId);

                // Sprawdź czy węzeł należy do innej ścieżki
                if (existingNode && existingNode.pathId !== pathId) {
                    // Dodaj wirtualny węzeł dla lepszego renderowania
                    const virtualNodeId = `virtual-${parentId}-${sceneId}`;
                    flatData.push({
                        id: virtualNodeId,
                        parentId: parentId,
                        name: sceneId,
                        isVirtual: true,
                        targetScene: sceneId,
                        nodeType,
                        pathId,
                        crossPath: true
                    });
                } else {
                    // Jeśli jest w tej samej ścieżce, dodaj standardowy wirtualny węzeł
                    const virtualNodeId = `virtual-${parentId}-${sceneId}`;
                    flatData.push({
                        id: virtualNodeId,
                        parentId: parentId,
                        name: sceneId,
                        isVirtual: true,
                        targetScene: sceneId,
                        nodeType,
                        pathId
                    });
                }
                return;
            }

            // Dodajemy scenę do przetworzonych
            processedNodes.add(sceneId);

            // Dodajemy węzeł do danych
            flatData.push({
                id: sceneId,
                parentId: parentId,
                name: sceneId,
                scene: scene,
                nodeType,
                depth,
                pathId
            });

            // Przetwarzamy wszystkie wybory
            if (scene.choices && scene.choices.length > 0) {
                scene.choices.forEach((choice, i) => {
                    const nextSceneId = choice.nextScene;
                    // Zapisujemy tekst wyboru
                    flatData.find(d => d.id === sceneId).choices =
                        flatData.find(d => d.id === sceneId).choices || [];
                    flatData.find(d => d.id === sceneId).choices[i] = choice.text;

                    // Przetwarzamy następną scenę
                    processScene(nextSceneId, sceneId, depth + 1, pathId);
                });
            }
        }

        // Zaczynamy od sceny "intro" dla aktualnej podróży
        processScene(`travel${currentTravelId}_intro`);

        // Tworzymy hierarchię
        const hierarchy = stratify(flatData);

        // Wybieramy odpowiedni layout
        let layout;
        switch (layoutType) {
            case 'tree':
                layout = d3.tree().size([height - 80, width - 100]);
                break;
            case 'cluster':
                layout = d3.cluster().size([height - 80, width - 100]);
                break;
            case 'radial':
                // Dla układu radialnego używamy mniejszy promień, aby zmieścić graf
                const radius = Math.min(width, height) / 2 - 80;
                layout = d3.cluster()
                    .size([2 * Math.PI, radius])
                    .separation((a, b) => (a.parent == b.parent ? 1 : 2) / a.depth);
                break;
            default:
                layout = d3.tree().size([height - 80, width - 100]);
        }

        // Aplikujemy układ do hierarchii
        return layout(hierarchy);
    }

    // Wykrywanie martwych końców
    function detectDeadEnds(root) {
        let deadEnds = [];

        root.eachAfter(node => {
            if (node.data.isDeadEnd) {
                node.data.nodeType = 'deadEnd';
                deadEnds.push(node);

                // Dodajemy dodatkową przestrzeń wokół martwych końców dla lepszej widoczności
                if (node.parent && node.parent.children && node.parent.children.length > 1) {
                    // Znajdujemy indeks bieżącego węzła w dzieciach rodzica
                    const index = node.parent.children.indexOf(node);

                    // Dodajemy małe przesunięcie dla sąsiednich węzłów dla lepszej widoczności
                    if (index > 0) {
                        // Przesuwamy poprzedni węzeł nieco w lewo
                        const prevNode = node.parent.children[index - 1];
                        if (currentLayout === 'radial') {
                            prevNode.x -= 0.1; // Małe przesunięcie kątowe
                        } else {
                            prevNode.x -= 10; // Przesunięcie w pikselach
                        }
                    }

                    if (index < node.parent.children.length - 1) {
                        // Przesuwamy następny węzeł nieco w prawo
                        const nextNode = node.parent.children[index + 1];
                        if (currentLayout === 'radial') {
                            nextNode.x += 0.1; // Małe przesunięcie kątowe
                        } else {
                            nextNode.x += 10; // Przesunięcie w pikselach
                        }
                    }
                }
            }
        });

        return deadEnds;
    }

    // Renderowanie grafu
    function renderGraph() {
        // Clear the canvas
        g.selectAll("*").remove();

        // Add arrow marker for cross-path connections
        addArrowMarker();

        // Ustawiamy flagę animacji
        isAnimatingLayout = true;

        // Set appropriate transformations for different layouts
        if (currentLayout === 'radial') {
            g.attr("transform", `translate(${width/2},${height/2})`);
        } else {
            g.attr("transform", `translate(50,40)`);
        }

        // Create appropriate link generator
        let linkGenerator;
        if (currentLayout === 'radial') {
            linkGenerator = d3.linkRadial()
                .angle(d => d.x)
                .radius(d => d.y);
        } else {
            linkGenerator = d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x);
        }

        // Draw regular tree links with animation
        const links = g.selectAll(".link")
            .data(root.links())
            .enter()
            .append("path")
            .attr("class", "link")
            .attr("d", linkGenerator)
            .attr("opacity", 0) // Start with opacity 0
            .transition()
            .duration(800)
            .attr("opacity", 1); // Animate to full opacity

        // Draw nodes
        const nodes = g.selectAll(".node")
            .data(root.descendants())
            .enter()
            .append("g")
            .attr("class", d => {
                let classes = "node";
                if (d.data.isDeadEnd) classes += " dead-end";
                return classes;
            })
            .attr("transform", d => {
                if (currentLayout === 'radial') {
                    const x = Math.sin(d.x) * d.y;
                    const y = -Math.cos(d.x) * d.y;
                    return `translate(${x},${y})`;
                } else {
                    return `translate(${d.y},${d.x})`;
                }
            })
            .on("click", function(event, d) {
                // Clear previous selection
                d3.selectAll(".node").classed("selected", false);

                // Mark this node as selected
                d3.select(this).classed("selected", true);
                selectedNode = d;

                // Display scene info
                const sceneId = d.data.isVirtual ? d.data.targetScene : d.data.id;
                displaySceneInfo(sceneId);
            })
            .on("mouseover", function(event, d) {
                event.stopPropagation();

                d3.select(this).classed("hover", true);

                d3.select(this).select("circle")
                    .transition().duration(200)
                    .attr("r", nodeRadius * 1.3);

                showTooltip(event, d);

                // Dodajemy informacje o cross-path do tooltipa
                updateTooltipWithCrossPathInfo(d);

                if (labelMode === 'hover') {
                    d3.select(this).select("text").style("opacity", 1);
                }
            })
            .on("mouseout", function() {
                d3.select(this).classed("hover", false);

                d3.select(this).select("circle")
                    .transition().duration(200)
                    .attr("r", nodeRadius);

                tooltip.style("opacity", 0);

                if (labelMode === 'hover') {
                    d3.select(this).select("text").style("opacity", 0);
                }
            });

        // Add circles for nodes with entering animation
        nodes.append("circle")
            .attr("r", 0) // Start with radius 0
            .attr("fill", d => {
                if (d.data.isDeadEnd) return nodeColors.deadEnd;

                const sceneId = d.data.isVirtual ? d.data.targetScene : d.data.id;
                const nodeType = d.data.nodeType;
                return nodeColors[nodeType];
            })
            .attr("stroke", d => d.data.isDeadEnd ? "#ef4444" : "#d1d5db")
            .attr("stroke-width", d => d.data.isDeadEnd ? 3 : 2)
            .transition() // Add transition
            .duration(800)
            .attr("r", nodeRadius); // Animate to full radius

        // Add X marks for dead ends
        nodes.filter(d => d.data.isDeadEnd)
            .append("g")
            .attr("class", "node-x")
            .call(g => {
                g.append("circle")
                    .attr("r", nodeRadius * 0.9)
                    .attr("fill", "#fff")
                    .attr("stroke", "#ef4444")
                    .attr("stroke-width", 1);

                g.append("line")
                    .attr("x1", -nodeRadius/1.2)
                    .attr("y1", -nodeRadius/1.2)
                    .attr("x2", nodeRadius/1.2)
                    .attr("y2", nodeRadius/1.2)
                    .attr("stroke", "#ef4444")
                    .attr("stroke-width", 3)
                    .attr("stroke-linecap", "round");

                g.append("line")
                    .attr("x1", nodeRadius/1.2)
                    .attr("y1", -nodeRadius/1.2)
                    .attr("x2", -nodeRadius/1.2)
                    .attr("y2", nodeRadius/1.2)
                    .attr("stroke", "#ef4444")
                    .attr("stroke-width", 3)
                    .attr("stroke-linecap", "round");
            });

        // Add backgrounds for labels
        nodes.append("rect")
            .attr("class", "label-background")
            .attr("x", -25)
            .attr("y", -25)
            .attr("width", 50)
            .attr("height", 20)
            .attr("opacity", 0);

        // Add node labels
        nodes.append("text")
            .attr("dy", -15)
            .attr("x", 0)
            .text(d => {
                let name;
                if (d.data.isDeadEnd) {
                    return "Brak sceny!";
                } else {
                    name = d.data.isVirtual ? d.data.targetScene : d.data.id;
                    name = name.replace(/^travel\d+_/, '');
                }
                return name.length > 10 ? name.substring(0, 8) + '..' : name;
            })
            .style("opacity", labelMode === 'visible' ? 1 : 0);

        // Update mode indicator
        document.querySelector('.mode-indicator').textContent =
            `Tryb: ${currentLayout.charAt(0).toUpperCase() + currentLayout.slice(1)}`;

        // Aktualizujemy podświetlenie węzłów z cross-path
        if (highlightCrossPathNodes) {
            updateCrossPathNodesHighlight();
        }

        // Po zakończeniu wszystkich animacji, renderujemy połączenia cross-path
        setTimeout(() => {
            isAnimatingLayout = false;
            if (showCrossPaths) {
                renderCrossPathLinks();
            }
        }, 900);
    }

    // Całkowicie przepisana funkcja wyświetlania tooltipa
    function showTooltip(event, d) {
        // Podstawowe informacje o scenie
        const sceneId = d.data.isVirtual ? d.data.targetScene : d.data.id;
        const scene = d.data.isDeadEnd ? null : scenesData[sceneId];

        // Ustawienie treści tooltipa
        let title = d.data.isDeadEnd ? "Brak sceny!" : sceneId.replace(/^travel\d+_/, '');
        tooltip.select(".tooltip-title").text(title);

        if (d.data.isDeadEnd) {
            tooltip.select(".tooltip-quote").text("Ta ścieżka prowadzi do nieistniejącej sceny.")
                .style("display", "block")
                .style("color", "#ef4444");
        } else if (scene && scene.quote) {
            tooltip.select(".tooltip-quote").text(`"${scene.quote}"`)
                .style("display", "block")
                .style("color", "#6b7280");
        } else {
            tooltip.select(".tooltip-quote").style("display", "none");
        }

        // Pobieramy pozycję kursora
        const mouseX = event.clientX;
        const mouseY = event.clientY;

        // Stała szerokość tooltipa
        const tooltipWidth = 280;

        // Granice widocznego obszaru okna
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Domyślne położenie - po prawej stronie kursora
        let xPos = mouseX + 10;
        let yPos = mouseY + 10;

        // Sprawdzamy czy tooltip wyjdzie poza prawą krawędź
        if (xPos + tooltipWidth > viewportWidth) {
            xPos = Math.max(0, mouseX - tooltipWidth - 10); // umieść po lewej stronie kursora
        }

        // Sprawdzamy czy tooltip wyjdzie poza dolną krawędź
        // Najpierw ustawiamy tooltip, aby poznać jego wysokość
        tooltip.style("left", "0px").style("top", "0px").style("opacity", "0");
        const tooltipHeight = tooltip.node().getBoundingClientRect().height;

        if (yPos + tooltipHeight > viewportHeight) {
            yPos = Math.max(0, mouseY - tooltipHeight - 10); // umieść nad kursorem
        }

        // Ustawiamy tooltip w finalnej pozycji
        tooltip
            .style("left", xPos + "px")
            .style("top", yPos + "px")
            .style("opacity", 1);
    }

    // Wyświetlanie informacji o scenie
    function displaySceneInfo(sceneId) {
        const scene = scenesData[sceneId];
        if (!scene) {
            // Obsługa martwego końca lub nieistniejącej sceny
            const infoPanel = document.querySelector('.scene-info');
            infoPanel.innerHTML = `
                <h3 style="color: #ef4444;">⚠️ Brak sceny: ${sceneId.replace(/^travel\d+_/, '')}</h3>
                <div class="quote" style="color: #ef4444; background-color: rgba(239, 68, 68, 0.1); border-left-color: #ef4444;">
                    "Ta scena nie istnieje w bazie danych. To martwy koniec w drzewie wyborów."
                </div>
                <div class="text" style="margin-top: 15px; padding: 10px; background-color: rgba(239, 68, 68, 0.05); border-radius: 4px;">
                    <strong>Problem:</strong> Ta ścieżka prowadzi do nieistniejącej sceny.<br><br>
                    <strong>Rozwiązanie:</strong> Należy dodać tę scenę do pliku JSON lub poprawić referencję do niej.
                </div>
            `;
            return;
        }

        const infoPanel = document.querySelector('.scene-info');
        const sceneName = sceneId.replace(/^travel\d+_/, '');

        let html = `<h3>Scena: ${sceneName}</h3>`;

        if (scene.quote) {
            html += `<div class="quote">"${scene.quote}"</div>`;
        }

        if (scene.text) {
            // Pokazujemy pełny tekst, pozwalając na scroll
            const textWithoutTags = scene.text.replace(/<\/?[^>]+(>|$)/g, "");
            html += `<div class="text">${textWithoutTags}</div>`;
        }

        // Sprawdzamy, czy scena ma połączenia cross-path
        if (crossPathNodes.has(sceneId)) {
            // Znajdujemy połączenia dla tej sceny
            const connections = crossPathLinks.filter(link =>
                link.source === sceneId || link.target === sceneId
            );

            if (connections.length > 0) {
                html += `
                <div class="cross-path-info">
                    <div class="cross-path-info-title">Połączenia między ścieżkami (${connections.length}):</div>
                    <div style="margin-top: 5px;">
                `;

                connections.forEach(link => {
                    const isSource = link.source === sceneId;
                    const otherNodeId = isSource ? link.target : link.source;
                    const otherNodeName = otherNodeId.replace(/^travel\d+_/, '');

                    html += `<div style="margin-bottom: 5px;">
                        <span style="color: #6366f1; font-weight: bold;">${isSource ? "→" : "←"}</span>
                        <span style="cursor: pointer; text-decoration: underline;"
                              onclick="focusOnScene('${otherNodeId}'); displaySceneInfo('${otherNodeId}');">
                            ${otherNodeName}
                        </span>
                    </div>`;
                });

                html += `</div></div>`;
            }
        }

        if (scene.choices && scene.choices.length > 0) {
            html += `<div class="choices"><h4>Wybory:</h4>`;
            scene.choices.forEach(choice => {
                // Usuwamy prefix podróży dla czytelności
                const nextScene = choice.nextScene.replace(/^travel\d+_/, '');
                html += `<div class="choice-item" data-scene="${choice.nextScene}">${choice.text} → <strong>${nextScene}</strong></div>`;
            });
            html += `</div>`;
        } else {
            html += `<div><em>Scena końcowa lub powrót do początku</em></div>`;
        }

        infoPanel.innerHTML = html;

        // Przewijanie do początku panelu informacyjnego
        const infoContainer = document.querySelector('.scene-info-container');
        infoContainer.scrollTop = 0;

        // Obsługa kliknięcia na wybory
        document.querySelectorAll('.choice-item').forEach(item => {
            item.addEventListener('click', function() {
                const nextSceneId = this.getAttribute('data-scene');
                focusOnScene(nextSceneId);
                displaySceneInfo(nextSceneId);
            });
        });
    }

    // Fokusowanie na konkretnej scenie
    function focusOnScene(sceneId) {
        // Najpierw szukamy węzła bezpośrednio o danym id
        let node = root.descendants().find(d => d.data.id === sceneId);

        // Jeśli nie znaleziono bezpośrednio, szukamy wirtualnych węzłów wskazujących na tę scenę
        if (!node) {
            node = root.descendants().find(d =>
                d.data.isVirtual && d.data.targetScene === sceneId
            );
        }

        // Jeśli nadal nie znaleziono, szukamy martwych końców związanych z tą sceną
        if (!node) {
            node = root.descendants().find(d =>
                d.data.isDeadEnd && d.data.name === sceneId
            );
        }

        if (node) {
            // Usuń poprzednie zaznaczenie
            d3.selectAll(".node").classed("selected", false);

            // Zaznacz znaleziony węzeł
            d3.selectAll(".node").filter(d => d === node).classed("selected", true);
            selectedNode = node;

            let transform;

            if (currentLayout === 'radial') {
                // Dla układu radialnego
                const x = Math.sin(node.x) * node.y;
                const y = -Math.cos(node.x) * node.y;
                transform = d3.zoomIdentity
                    .translate(width/2 - x, height/2 - y)
                    .scale(1.2);
            } else {
                // Dla układu drzewa i klastra
                transform = d3.zoomIdentity
                    .translate(width/2 - node.y, height/2 - node.x)
                    .scale(1.2);
            }

            svg.transition().duration(750).call(zoom.transform, transform);
        }
    }

    // Obliczanie statystyk
    function calculateStatistics(root) {
        // Unikalne sceny (bez wirtualnych)
        const uniqueScenes = new Set();
        root.descendants().forEach(d => {
            if (!d.data.isVirtual && !d.data.isDeadEnd) {
                uniqueScenes.add(d.data.id);
            }
        });

        const totalScenes = uniqueScenes.size;

        // Liczba wyborów
        let totalChoices = 0;
        Object.values(scenesData).forEach(scene => {
            if (scene.choices) {
                totalChoices += scene.choices.length;
            }
        });

        // Liczba scen końcowych
        const endScenes = root.descendants()
            .filter(d => !d.data.isVirtual && !d.data.isDeadEnd && d.data.nodeType === 'end')
            .length;

        // Liczba martwych końców
        const deadEnds = root.descendants()
            .filter(d => d.data.isDeadEnd)
            .length;

        // Liczba połączeń między ścieżkami
        const crossPathsCount = crossPathLinks.length;

        // Aktualizujemy statystyki w interfejsie
        document.getElementById('totalScenes').textContent = totalScenes;
        document.getElementById('totalChoices').textContent = totalChoices;
        document.getElementById('endScenes').textContent = endScenes;
        document.getElementById('deadEnds').textContent = deadEnds;
        document.getElementById('crossPathLinks').textContent = crossPathsCount;
        document.getElementById('pathCrossings').textContent = crossPathsCount;

        // Update stats panel if it exists
        if (document.getElementById('totalScenes-panel')) {
            document.getElementById('totalScenes-panel').textContent = totalScenes;
            document.getElementById('totalChoices-panel').textContent = totalChoices;
            document.getElementById('endScenes-panel').textContent = endScenes;
            document.getElementById('deadEnds-panel').textContent = deadEnds;
            document.getElementById('crossPathLinks-panel').textContent = crossPathsCount;
            document.getElementById('pathCrossings-panel').textContent = crossPathsCount;
        }

        // Aktualizujemy statystyki w panelu cross-path jeśli istnieje
        if (document.getElementById('cross-path-count')) {
            document.getElementById('cross-path-count').textContent = crossPathsCount;
            document.getElementById('cross-path-nodes-count').textContent = crossPathNodes.size;
        }
    }

    // Konfiguracja interakcji
    function setupInteractions() {
        // Przycisk powiększania
        document.getElementById('zoomIn').addEventListener('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 1.3);
        });

        // Przycisk pomniejszania
        document.getElementById('zoomOut').addEventListener('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 0.7);
        });

        // Przycisk resetowania widoku
        document.getElementById('resetView').addEventListener('click', resetView);

        // Przycisk powrotu do początku
        document.getElementById('focusIntro').addEventListener('click', () => {
            focusOnScene(`travel${currentTravelId}_intro`);
            displaySceneInfo(`travel${currentTravelId}_intro`);
        });

        // Przycisk przełączania widoczności cross-path
        document.getElementById('toggleCrossPaths').addEventListener('click', toggleCrossPathVisibility);

        // Przycisk przełączania podświetlenia węzłów z cross-path
        document.getElementById('highlightCrossPathNodes').addEventListener('click', toggleHighlightCrossPathNodes);

        // Obsługa wyszukiwania
        document.getElementById('searchInput').addEventListener('input', function() {
            const query = this.value.toLowerCase();
            if (query.length < 2) {
                // Przywracamy normalny widok
                d3.selectAll(".node circle")
                    .attr("r", nodeRadius)
                    .attr("opacity", 1);
                return;
            }

            // Wyszukujemy pasujące węzły
            const nodes = d3.selectAll(".node");
            nodes.each(function(d) {
                const sceneName = d.data.id.replace(/^travel\d+_/, '').toLowerCase();
                const isMatch = sceneName.includes(query);

                // Podświetlamy pasujące węzły
                d3.select(this).select("circle")
                    .transition()
                    .duration(300)
                    .attr("r", isMatch ? nodeRadius * 1.5 : nodeRadius)
                    .attr("opacity", isMatch ? 1 : 0.3);
            });

            // Znajdujemy pierwszy pasujący węzeł
            const matchingNode = root.descendants().find(d =>
                d.data.id.replace(/^travel\d+_/, '').toLowerCase().includes(query)
            );

            if (matchingNode) {
                focusOnScene(matchingNode.data.id);
            }
        });

        // Obsługa zmiany layoutu
        document.querySelectorAll('.layout-option').forEach(option => {
            option.addEventListener('click', function() {
                // Jeśli trwa animacja, pomijamy zmianę layoutu
                if (isAnimatingLayout) return;

                // Usuwamy klasę active z wszystkich opcji
                document.querySelectorAll('.layout-option').forEach(o => {
                    o.classList.remove('active');
                });

                // Dodajemy klasę active do wybranej opcji
                this.classList.add('active');

                // Zmieniamy layout
                currentLayout = this.getAttribute('data-layout');

                // Przetwarzamy dane na nowo z nowym layoutem
                root = processData(currentLayout);

                // Wykrywamy martwe końce i połączenia między ścieżkami
                detectDeadEnds(root);
                detectAllCrossPaths();

                // Renderujemy graf na nowo
                renderGraph();

                // Resetujemy widok
                resetView();
            });
        });

        // Obsługa podwójnego kliknięcia na węzeł (przełączanie etykiet)
        svg.on("dblclick", function(event) {
            // Zatrzymujemy domyślne zachowanie (zoom)
            if (event) event.preventDefault();

            // Zmieniamy tryb etykiet
            if (labelMode === 'tooltip') {
                labelMode = 'visible';
                d3.selectAll(".node text").style("opacity", 1);
                d3.selectAll(".label-background").style("opacity", 0.7);
            } else if (labelMode === 'visible') {
                labelMode = 'hover';
                d3.selectAll(".node text").style("opacity", 0);
                d3.selectAll(".label-background").style("opacity", 0);
            } else {
                labelMode = 'tooltip';
                d3.selectAll(".node text").style("opacity", 0);
                d3.selectAll(".label-background").style("opacity", 0);
            }
        });

        // Obsługa klawiatury - strzałki do nawigacji
        document.addEventListener('keydown', function(event) {
            if (!selectedNode) return;

            let nextNode = null;

            // Znajdź sąsiednie węzły
            if (event.key === 'ArrowUp') {
                // Znajdź poprzedni węzeł (rodzic)
                nextNode = selectedNode.parent;
            } else if (event.key === 'ArrowDown') {
                // Znajdź pierwszy węzeł dziecko
                nextNode = selectedNode.children ? selectedNode.children[0] : null;
            } else if (event.key === 'ArrowLeft') {
                // Znajdź poprzedni węzeł na tym samym poziomie
                if (selectedNode.parent) {
                    const siblings = selectedNode.parent.children;
                    const currentIndex = siblings.indexOf(selectedNode);
                    if (currentIndex > 0) {
                        nextNode = siblings[currentIndex - 1];
                    }
                }
            } else if (event.key === 'ArrowRight') {
                // Znajdź następny węzeł na tym samym poziomie
                if (selectedNode.parent) {
                    const siblings = selectedNode.parent.children;
                    const currentIndex = siblings.indexOf(selectedNode);
                    if (currentIndex < siblings.length - 1) {
                        nextNode = siblings[currentIndex + 1];
                    }
                }
            }

            if (nextNode) {
                // Zaznacz nowy węzeł
                d3.selectAll(".node").classed("selected", false);
                d3.selectAll(".node").filter(d => d === nextNode).classed("selected", true);
                selectedNode = nextNode;

                // Pokaż informacje o scenie
                const sceneId = nextNode.data.isVirtual ? nextNode.data.targetScene : nextNode.data.id;
                displaySceneInfo(sceneId);

                // Przewiń widok do nowego węzła
                focusOnScene(sceneId);

                // Zapobiegaj domyślnej akcji przeglądarki (przewijanie strony)
                event.preventDefault();
            }
        });
    }

    // Resetowanie widoku
    function resetView() {
        if (currentLayout === 'radial') {
            // Dla układu radialnego, centrujemy graf
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(width/2, height/2)
                    .scale(0.9));
        } else {
            // Dla innych układów
            const bounds = g.node().getBBox();
            const fullWidth = bounds.width + 100;
            const fullHeight = bounds.height + 80;

            const scale = 0.9 / Math.max(fullWidth / width, fullHeight / height);
            const translateX = width / 2 - scale * (bounds.x + fullWidth / 2);
            const translateY = height / 2 - scale * (bounds.y + fullHeight / 2);

            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale));
        }
    }

    // Create travel selector panel
    function createTravelPanel() {
        // Create the panel
        const panel = d3.select('#panels-container')
            .append('div')
            .attr('class', 'floating-panel travel-panel')
            .html(`
                <h3 class="panel-title">
                    Wybierz podróż
                    <span class="panel-toggle" id="travel-toggle">▼</span>
                </h3>
                <div class="panel-content" id="travel-panel-content">
                    <div id="floating-travel-options"></div>
                </div>
            `);

        // Make entire header clickable
        panel.select(".panel-title").on("click", function() {
            const content = document.getElementById('travel-panel-content');
            const toggle = document.getElementById('travel-toggle');

            content.classList.toggle('collapsed');
            toggle.textContent = content.classList.contains('collapsed') ? '▲' : '▼';
        });

        // Populate travel options
        const travelOptionsContainer = document.getElementById('floating-travel-options');

        window.travelsConfig.forEach(travel => {
            const option = document.createElement('div');
            option.className = 'travel-option' + (travel.id === currentTravelId ? ' active' : '');
            option.textContent = travel.name;
            option.setAttribute('data-travel-id', travel.id);

            option.addEventListener('click', function() {
                // Remove active class from all options
                document.querySelectorAll('.travel-option').forEach(opt => {
                    opt.classList.remove('active');
                });

                // Add active class to selected option
                this.classList.add('active');

                // Load data for selected travel
                currentTravelId = parseInt(this.getAttribute('data-travel-id'));
                loadTravelData(currentTravelId);
            });

            travelOptionsContainer.appendChild(option);
        });

        return panel;
    }

    // Function to create and update the statistics panel
    function createStatsPanel() {
        // Create the panel
        const panel = d3.select('#panels-container')
            .append('div')
            .attr('class', 'floating-panel stats-panel')
            .html(`
                <h3 class="panel-title">
                    Statystyki
                    <span class="panel-toggle" id="stats-toggle">▼</span>
                </h3>
                <div class="panel-content" id="stats-content">
                    <div class="stat-item">
                        <span>Łączna liczba scen:</span>
                        <span id="totalScenes-panel">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Liczba wyborów:</span>
                        <span id="totalChoices-panel">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Sceny końcowe:</span>
                        <span id="endScenes-panel">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Martwe końce:</span>
                        <span id="deadEnds-panel">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Połączenia między ścieżkami:</span>
                        <span id="crossPathLinks-panel" class="stat-highlight">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Przecięcia ścieżek:</span>
                        <span id="pathCrossings-panel" class="stat-highlight">0</span>
                    </div>
                </div>
            `);

        // Make entire header clickable
        panel.select(".panel-title").on("click", function() {
            const content = document.getElementById('stats-content');
            const toggle = document.getElementById('stats-toggle');

            content.classList.toggle('collapsed');
            toggle.textContent = content.classList.contains('collapsed') ? '▲' : '▼';
        });

        // Update stats in panel from main stats
        function updateStatsPanel() {
            document.getElementById('totalScenes-panel').textContent =
                document.getElementById('totalScenes').textContent;
            document.getElementById('totalChoices-panel').textContent =
                document.getElementById('totalChoices').textContent;
            document.getElementById('endScenes-panel').textContent =
                document.getElementById('endScenes').textContent;
            document.getElementById('deadEnds-panel').textContent =
                document.getElementById('deadEnds').textContent;
            document.getElementById('crossPathLinks-panel').textContent =
                document.getElementById('crossPathLinks').textContent;
            document.getElementById('pathCrossings-panel').textContent =
                document.getElementById('pathCrossings').textContent;
        }

        // Initial update
        updateStatsPanel();

        // Set up an observer to update the panel when the main stats change
        const statsObserver = new MutationObserver(updateStatsPanel);
        statsObserver.observe(document.getElementById('totalScenes'), { childList: true });
        statsObserver.observe(document.getElementById('crossPathLinks'), { childList: true });

        return panel;
    }

    // Inicjalizacja po załadowaniu strony
    window.addEventListener('DOMContentLoaded', () => {
        initVisualization();
    });
</script>
</body>
</html>