<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drzewko Wyborów</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #333;
            overflow: hidden; /* Prevent overall body scrolling */
        }

        .container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 350px; /* Increased width from 300px to 350px */
            background: #fff;
            border-right: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Make the entire sidebar scrollable */
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
        }

        .main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 0;
            z-index: 20;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            color: #374151;
        }

        .travel-selector {
            padding: 10px 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 60px;
            z-index: 19;
            display: none; /* Hide the original travel selector */
        }

        .travel-selector h3 {
            margin: 0 0 10px 0;
            font-size: 1rem;
            color: #4b5563;
        }

        .travel-option {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: #f3f4f6;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .travel-option:hover {
            background: #e5e7eb;
        }

        .travel-option.active {
            background: #d1d5db;
            font-weight: 600;
        }

        .controls {
            padding: 10px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 60px; /* Adjusted due to removal of travel selector */
            z-index: 18;
        }

        button {
            padding: 8px 12px;
            background: #4b5563;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        button:hover {
            background: #374151;
        }

        button.active {
            background: #1f2937;
        }

        .layout-options {
            display: flex;
            padding: 10px 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 110px; /* Adjusted due to removal of travel selector */
            z-index: 17;
        }

        .layout-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .layout-option:hover {
            background: #f3f4f6;
        }

        .layout-option.active {
            background: #e5e7eb;
            font-weight: bold;
        }

        .search-box {
            padding: 10px 20px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            position: sticky;
            top: 160px; /* Adjusted due to removal of travel selector */
            z-index: 16;
        }

        .search-box input {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .scene-info-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: auto; /* Make this container scrollable */
            margin-bottom: 10px; /* Space between info and statistics */
            min-height: 400px; /* Set minimum height */
            max-height: calc(100vh - 330px); /* Ensure there's room for the stats */
        }

        .scene-info {
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .scene-info h3 {
            margin-top: 0;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 10px;
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
        }

        .quote {
            font-style: italic;
            color: #6b7280;
            margin: 15px 0;
            padding: 10px;
            background: #f3f4f6;
            border-left: 4px solid #9ca3af;
            border-radius: 0 4px 4px 0;
        }

        .text {
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .choices {
            margin-top: 20px;
            margin-bottom: 20px; /* Added margin bottom */
            padding-bottom: 10px; /* Extra padding at bottom */
        }

        .choices h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #4b5563;
        }

        .choice-item {
            margin-bottom: 10px;
            padding: 10px;
            background: #f3f4f6;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid #9ca3af;
        }

        .choice-item:hover {
            background: #e5e7eb;
        }

        .statistics {
            padding: 15px 20px;
            background: #f3f4f6;
            border-top: 1px solid #e5e7eb;
            font-size: 0.9rem;
            flex-shrink: 0; /* Prevent statistics from shrinking */
            position: sticky;
            bottom: 0;
            z-index: 15;
            display: none; /* Hidden, but still there for data binding */
        }

        .statistics h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1rem;
            color: #374151;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        /* Status ładowania */
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            text-align: center;
            z-index: 9999;
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid #3b82f6;
            width: 30px;
            height: 30px;
            margin: 0 auto 10px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Stylowanie grafu */
        #visualization {
            width: 100%;
            height: 100%;
            background: #fff;
        }

        .node circle {
            stroke-width: 2px;
        }

        .link {
            fill: none;
            stroke-width: 1.5px;
            stroke: #d1d5db;
        }

        /* More subtle cross-path styling */
        .link.cross-path, .cross-path-connection {
            stroke-dasharray: 5, 3;
            stroke: #6366f1; /* Indigo color - less harsh than bright red */
            stroke-width: 1.5px;
            stroke-opacity: 0.8;
            pointer-events: all;
            cursor: pointer;
            fill: none; /* Explicitly set fill to none */
        }

        /* Cross-path arrow styling */
        .cross-path-arrow {
            fill: #6366f1;
            stroke: none;
        }

        /* Floating panels styles */
        .floating-panel {
            position: fixed;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 12px 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 0.9rem;
            z-index: 900;
            max-width: 250px;
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Travel panel */
        .travel-panel {
            bottom: 100px; /* Position above stats panel */
        }

        /* Stats panel */
        .stats-panel {
            bottom: 20px;
        }

        .panel-title {
            margin: 0 0 8px 0;
            font-size: 1rem;
            color: #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-toggle {
            cursor: pointer;
            font-size: 0.8rem;
            color: #6b7280;
        }

        .panel-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .panel-content.collapsed {
            max-height: 0;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            color: #4b5563;
        }

        .stat-item span:first-child {
            margin-right: 10px;
        }

        .stat-item span:last-child {
            font-weight: 500;
            color: #1f2937;
        }

        /* Highlight for cross-path connections */
        .stat-highlight {
            color: #4f46e5;
            font-weight: bold;
        }

        /* Add a badge for cross-path count */
        .cross-path-badge {
            background: #6366f1;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: bold;
            display: inline-block;
            margin-left: 5px;
        }

        /* Updated hover states for crosspath connections */
        .cross-path-connection:hover {
            stroke-width: 2.5px;
            stroke: #4f46e5;
            stroke-opacity: 1;
        }

        /* Custom tooltip styles */
        .tooltip {
            position: fixed; /* Use fixed instead of absolute */
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.2);
            width: 280px; /* Fixed width */
            z-index: 9999;
            pointer-events: none;
            box-sizing: border-box;
            max-height: 200px;
            overflow-y: auto;
            opacity: 0;
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .tooltip-quote {
            font-style: italic;
            color: #6b7280;
            margin-top: 5px;
            font-size: 13px;
        }

        .mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: #6b7280;
        }

        /* Etykiety węzłów */
        .node text {
            font-size: 10px;
            font-family: Arial, sans-serif;
            fill: #4b5563;
            text-anchor: middle;
            pointer-events: none;
            dominant-baseline: middle;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px;
        }

        .label-background {
            fill: rgba(255, 255, 255, 0.8);
            rx: 3;
            ry: 3;
        }

        /* Dead end node styling */
        .node.dead-end circle {
            stroke: #ef4444;
            stroke-width: 3px;
            filter: drop-shadow(0 0 5px rgba(239, 68, 68, 0.6));
        }

        .node-x {
            stroke: #ef4444;
            stroke-width: 3px;
        }

        /* Pulsing animation for dead end nodes */
        @keyframes pulse-deadend {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .node.dead-end circle {
            animation: pulse-deadend 2s infinite ease-in-out;
        }

        /* Node selection styling */
        .node.selected circle {
            stroke: #000;
            stroke-width: 3px;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.3));
        }

        /* Node hover styling */
        .node.hover circle {
            filter: drop-shadow(0 0 4px rgba(0,0,0,0.2));
        }

        /* Additional transition effects */
        .node circle, .link {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="sidebar">
        <div class="header">
            <h1 id="travelTitle">Drzewko Wyborów</h1>
        </div>

        <div class="travel-selector">
            <h3>Wybierz podróż:</h3>
            <div id="travel-options"></div>
        </div>

        <div class="controls">
            <button id="zoomIn">Powiększ</button>
            <button id="zoomOut">Pomniejsz</button>
            <button id="resetView">Reset widoku</button>
            <button id="focusIntro">Początek</button>
        </div>

        <div class="layout-options">
            <div class="layout-option active" data-layout="tree">Drzewo</div>
            <div class="layout-option" data-layout="cluster">Klaster</div>
            <div class="layout-option" data-layout="radial">Radialny</div>
        </div>

        <div class="search-box">
            <input type="text" id="searchInput" placeholder="Szukaj sceny...">
        </div>

        <div class="scene-info-container">
            <div class="scene-info">
                <h3>Wybierz scenę, aby zobaczyć szczegóły</h3>
                <p>Kliknij węzeł na grafie, aby wyświetlić informacje o danej scenie.</p>
            </div>
        </div>

        <!-- Statistics hidden, but kept for data binding -->
        <div class="statistics" style="display: none;">
            <h3>Statystyki</h3>
            <div class="stat-item">
                <span>Łączna liczba scen:</span>
                <span id="totalScenes">0</span>
            </div>
            <div class="stat-item">
                <span>Liczba wyborów:</span>
                <span id="totalChoices">0</span>
            </div>
            <div class="stat-item">
                <span>Sceny końcowe:</span>
                <span id="endScenes">0</span>
            </div>
            <div class="stat-item">
                <span>Martwe końce:</span>
                <span id="deadEnds">0</span>
            </div>
            <div class="stat-item">
                <span>Połączenia między ścieżkami:</span>
                <span id="crossPathLinks">0</span>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="visualization"></div>
        <div class="tooltip" id="tooltip">
            <div class="tooltip-title"></div>
            <div class="tooltip-quote"></div>
        </div>
        <div class="mode-indicator">Tryb: Drzewo</div>
        <div class="loading-indicator" id="loadingIndicator" style="display: none;">
            <div class="loading-spinner"></div>
            <p>Ładowanie danych...</p>
        </div>
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<!-- Add script to load travels configuration -->
<script src="travels.js"></script>
<script>
    // Globalne zmienne
    let svg, g;
    let zoom;
    let root;
    let width, height;
    let nodeRadius = 8;
    let tooltip;
    let currentLayout = 'tree';
    let labelMode = 'tooltip'; // 'tooltip', 'visible', 'hover'
    let selectedNode = null;
    let currentTravelId = 1; // Domyślnie pierwsza podróż
    let scenesData = {}; // Dane wszystkich scen
    let crossPathLinks = []; // Lista połączeń między ścieżkami

    // Kolory dla różnych typów węzłów
    const nodeColors = {
        'start': '#ef4444',  // czerwony
        'normal': '#3b82f6', // niebieski
        'end': '#22c55e',    // zielony
        'deadEnd': '#f97316' // pomarańczowy dla martwych końców
    };

    // Improved cross-path detection function
    function detectAllCrossPaths() {
        console.log("Starting comprehensive cross-path detection...");
        crossPathLinks = []; // Reset the array

        // Skip detection if scene data isn't available
        if (!scenesData || Object.keys(scenesData).length === 0) {
            console.error("No scene data available for cross-path detection");
            return;
        }

        const travelPrefix = `travel${currentTravelId}_`;
        const processedConnections = new Set(); // Track processed connections to avoid duplicates

        // Method 1: Direct scene number difference detection
        // This detects scenes that have a number difference > 1 (non-sequential)
        Object.entries(scenesData).forEach(([sceneId, scene]) => {
            if (!sceneId.startsWith(travelPrefix)) return;
            if (!scene.choices) return;

            scene.choices.forEach(choice => {
                if (!choice || !choice.nextScene) return;

                const targetId = choice.nextScene;

                // Skip intro-to-intro connections as requested
                if (sceneId.endsWith('_intro') || targetId.endsWith('_intro')) return;

                // Skip if target doesn't exist
                if (!scenesData[targetId]) return;

                try {
                    // Try to extract scene numbers safely
                    const sourceMatch = sceneId.match(/(\d+)$/);
                    const targetMatch = targetId.match(/(\d+)$/);

                    if (!sourceMatch || !targetMatch) return;

                    const sourceNum = parseInt(sourceMatch[0]);
                    const targetNum = parseInt(targetMatch[0]);

                    if (isNaN(sourceNum) || isNaN(targetNum)) return;

                    // Difference > 1 indicates a non-sequential jump
                    const diff = Math.abs(targetNum - sourceNum);

                    if (diff > 1) {
                        const connectionKey = `${sceneId}->${targetId}`;

                        // Avoid duplicates
                        if (!processedConnections.has(connectionKey)) {
                            processedConnections.add(connectionKey);

                            crossPathLinks.push({
                                source: sceneId,
                                target: targetId,
                                sourcePathId: sceneId,
                                targetPathId: targetId,
                                isDirect: true,
                                method: "number-diff",
                                difference: diff
                            });
                        }
                    }
                } catch (error) {
                    console.error(`Error in number-diff detection for ${sceneId} to ${targetId}:`, error);
                }
            });
        });

        console.log(`Found ${crossPathLinks.length} cross-paths using number difference method`);

        // Method 2: Tree structure analysis
        // This detects connections that aren't part of the direct parent-child structure in the tree
        if (root) {
            // Build a map of direct tree connections
            const treeConnections = new Set();
            root.links().forEach(link => {
                const source = link.source.data.id;
                const target = link.target.data.id;
                treeConnections.add(`${source}->${target}`);
            });

            // Check all choices against the tree structure
            Object.entries(scenesData).forEach(([sceneId, scene]) => {
                if (!sceneId.startsWith(travelPrefix)) return;
                if (!scene.choices) return;

                scene.choices.forEach(choice => {
                    if (!choice || !choice.nextScene) return;

                    const targetId = choice.nextScene;

                    // Skip intro connections
                    if (sceneId.endsWith('_intro') || targetId.endsWith('_intro')) return;

                    // Skip if target doesn't exist
                    if (!scenesData[targetId]) return;

                    const connectionKey = `${sceneId}->${targetId}`;

                    // If the connection is not in the tree but exists in the choices,
                    // it's a cross-path connection
                    if (!treeConnections.has(connectionKey) && !processedConnections.has(connectionKey)) {
                        processedConnections.add(connectionKey);

                        crossPathLinks.push({
                            source: sceneId,
                            target: targetId,
                            sourcePathId: sceneId,
                            targetPathId: targetId,
                            isDirect: true,
                            method: "tree-structure"
                        });
                    }
                });
            });

            console.log(`Added ${crossPathLinks.length - processedConnections.size + 1} cross-paths using tree structure method`);
        } else {
            console.warn("Root not available for tree structure detection");
        }

        // Method 3: Full graph analysis for reachability
        // This creates a complete graph from all choices and detects paths that
        // would be "shortcuts" in the story flow
        try {
            // Build a graph of all connections
            const allConnections = new Map();

            Object.entries(scenesData).forEach(([sceneId, scene]) => {
                if (!sceneId.startsWith(travelPrefix)) return;

                // Initialize node if not exists
                if (!allConnections.has(sceneId)) {
                    allConnections.set(sceneId, new Set());
                }

                // Add all direct connections from choices
                if (scene.choices) {
                    scene.choices.forEach(choice => {
                        if (choice && choice.nextScene && scenesData[choice.nextScene]) {
                            allConnections.get(sceneId).add(choice.nextScene);
                        }
                    });
                }
            });

            // Find all scenes that can reach each other indirectly (skipping over other scenes)
            allConnections.forEach((targets, source) => {
                if (source.endsWith('_intro')) return; // Skip intro scenes

                targets.forEach(target => {
                    if (target.endsWith('_intro')) return; // Skip intro scenes

                    const connectionKey = `${source}->${target}`;

                    // Skip already processed connections
                    if (processedConnections.has(connectionKey)) return;

                    // Get source and target numbers
                    const sourceMatch = source.match(/(\d+)$/);
                    const targetMatch = target.match(/(\d+)$/);

                    if (!sourceMatch || !targetMatch) return;

                    const sourceNum = parseInt(sourceMatch[0]);
                    const targetNum = parseInt(targetMatch[0]);

                    if (isNaN(sourceNum) || isNaN(targetNum)) return;

                    // Check if there are scenes between source and target
                    const diff = Math.abs(targetNum - sourceNum);

                    if (diff > 5) { // Significant jumps only
                        processedConnections.add(connectionKey);

                        crossPathLinks.push({
                            source: source,
                            target: target,
                            sourcePathId: source,
                            targetPathId: target,
                            isDirect: true,
                            method: "graph-analysis",
                            difference: diff
                        });
                    }
                });
            });

            console.log(`Total cross-paths after all methods: ${crossPathLinks.length}`);
        } catch (error) {
            console.error("Error in graph analysis method:", error);
        }

        // Update statistics
        document.getElementById('crossPathLinks').textContent = crossPathLinks.length;
        if (document.getElementById('crossPathLinks-panel')) {
            document.getElementById('crossPathLinks-panel').textContent = crossPathLinks.length;
        }
    }

    // Function to add marker for cross-path connections
    function addArrowMarker() {
        // Clear previous markers
        svg.select("defs").remove();

        // Add new marker with more subtle styling
        const defs = svg.append("defs");

        // Create end arrow marker
        defs.append("marker")
            .attr("id", "end-arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 6) // Smaller marker
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-4L8,0L0,4") // Slightly smaller arrow
            .attr("fill", "#6366f1") // Indigo color to match path
            .attr("stroke", "none"); // No stroke
    }

    // Enhanced function to render cross-path links
    function renderCrossPathLinks() {
        console.log(`Rendering ${crossPathLinks.length} cross-path connections`);

        // Safety check
        if (!root || !crossPathLinks || crossPathLinks.length === 0) {
            console.log("No cross-path links to render or missing root");
            return;
        }

        // Remove any existing cross-path connections
        g.selectAll(".cross-path-connection").remove();

        // Create a map for quick node lookup
        const nodeMap = new Map();
        root.descendants().forEach(node => {
            nodeMap.set(node.data.id, node);

            // Also map virtual nodes to their targets
            if (node.data.isVirtual && node.data.targetScene) {
                nodeMap.set(node.data.targetScene, node);
            }
        });

        // Render each cross-path connection
        let renderedCount = 0;

        crossPathLinks.forEach((link, index) => {
            try {
                // Skip intro connections
                if (link.source.endsWith('_intro') || link.target.endsWith('_intro')) {
                    return;
                }

                // Find source and target nodes
                const sourceNode = nodeMap.get(link.source);
                const targetNode = nodeMap.get(link.target);

                if (!sourceNode || !targetNode) {
                    // Skip this connection if nodes not found
                    return;
                }

                // Calculate coordinates based on layout
                let sx, sy, tx, ty;

                if (currentLayout === 'radial') {
                    sx = Math.sin(sourceNode.x) * sourceNode.y;
                    sy = -Math.cos(sourceNode.x) * sourceNode.y;
                    tx = Math.sin(targetNode.x) * targetNode.y;
                    ty = -Math.cos(targetNode.x) * targetNode.y;
                } else {
                    sx = sourceNode.y;
                    sy = sourceNode.x;
                    tx = targetNode.y;
                    ty = targetNode.x;
                }

                // Create the path
                const line = g.append("path")
                    .attr("class", "cross-path-connection")
                    .attr("d", () => {
                        const path = d3.path();

                        if (currentLayout === 'radial') {
                            // Curved path for radial layout
                            path.moveTo(sx, sy);

                            // Calculate control point for curvature
                            const midX = (sx + tx) / 2;
                            const midY = (sy + ty) / 2;
                            const dx = tx - sx;
                            const dy = ty - sy;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const offset = dist * 0.3;

                            // Perpendicular offset
                            const nx = -dy / dist * offset;
                            const ny = dx / dist * offset;

                            path.quadraticCurveTo(midX + nx, midY + ny, tx, ty);
                        } else {
                            // Bezier curve for tree layout
                            path.moveTo(sx, sy);

                            const midX = (sx + tx) / 2;
                            path.bezierCurveTo(
                                midX, sy,
                                midX, ty,
                                tx, ty
                            );
                        }

                        return path.toString();
                    })
                    .attr("fill", "none") // Explicitly set fill to none
                    .attr("marker-end", "url(#end-arrow)")
                    .on("click", function() {
                        focusOnScene(link.target);
                        displaySceneInfo(link.target);
                    });

                // Add tooltip with information about the connection
                line.append("title")
                    .text(`${link.source.replace(/^travel\d+_/, '')} → ${link.target.replace(/^travel\d+_/, '')}`);

                renderedCount++;
            } catch (error) {
                console.error(`Error rendering cross-path ${index}:`, error);
            }
        });

        console.log(`Successfully rendered ${renderedCount} cross-path connections`);
    }

    // Function to create and update the statistics panel
    function createStatsPanel() {
        // Remove any existing panel
        d3.select('.stats-panel').remove();

        // Create the panel
        const panel = d3.select('body')
            .append('div')
            .attr('class', 'floating-panel stats-panel')
            .html(`
                <h3 class="panel-title">
                    Statystyki
                    <span class="panel-toggle" id="stats-toggle">▼</span>
                </h3>
                <div class="panel-content" id="stats-content">
                    <div class="stat-item">
                        <span>Łączna liczba scen:</span>
                        <span id="totalScenes-panel">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Liczba wyborów:</span>
                        <span id="totalChoices-panel">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Sceny końcowe:</span>
                        <span id="endScenes-panel">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Martwe końce:</span>
                        <span id="deadEnds-panel">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Połączenia między ścieżkami:</span>
                        <span id="crossPathLinks-panel" class="stat-highlight">0</span>
                    </div>
                </div>
            `);

        // Add toggle functionality
        document.getElementById('stats-toggle').addEventListener('click', function() {
            const content = document.getElementById('stats-content');
            content.classList.toggle('collapsed');
            this.textContent = content.classList.contains('collapsed') ? '▲' : '▼';
        });

        // Update stats in panel from main stats
        function updateStatsPanel() {
            document.getElementById('totalScenes-panel').textContent =
                document.getElementById('totalScenes').textContent;
            document.getElementById('totalChoices-panel').textContent =
                document.getElementById('totalChoices').textContent;
            document.getElementById('endScenes-panel').textContent =
                document.getElementById('endScenes').textContent;
            document.getElementById('deadEnds-panel').textContent =
                document.getElementById('deadEnds').textContent;
            document.getElementById('crossPathLinks-panel').textContent =
                document.getElementById('crossPathLinks').textContent;
        }

        // Initial update
        updateStatsPanel();

        // Set up an observer to update the panel when the main stats change
        const statsObserver = new MutationObserver(updateStatsPanel);
        statsObserver.observe(document.getElementById('totalScenes'), { childList: true });
        statsObserver.observe(document.getElementById('crossPathLinks'), { childList: true });

        return panel;
    }

    // Create travel selector panel
    function createTravelPanel() {
        // Remove any existing panel
        d3.select('.travel-panel').remove();

        // Create the panel
        const panel = d3.select('body')
            .append('div')
            .attr('class', 'floating-panel travel-panel')
            .html(`
                <h3 class="panel-title">
                    Wybierz podróż
                    <span class="panel-toggle" id="travel-toggle">▼</span>
                </h3>
                <div class="panel-content" id="travel-panel-content">
                    <div id="floating-travel-options"></div>
                </div>
            `);

        // Add toggle functionality
        document.getElementById('travel-toggle').addEventListener('click', function() {
            const content = document.getElementById('travel-panel-content');
            content.classList.toggle('collapsed');
            this.textContent = content.classList.contains('collapsed') ? '▲' : '▼';
        });

        // Populate travel options
        const travelOptionsContainer = document.getElementById('floating-travel-options');

        window.travelsConfig.forEach(travel => {
            const option = document.createElement('div');
            option.className = 'travel-option' + (travel.id === currentTravelId ? ' active' : '');
            option.textContent = travel.name;
            option.setAttribute('data-travel-id', travel.id);

            option.addEventListener('click', function() {
                // Remove active class from all options
                document.querySelectorAll('.travel-option').forEach(opt => {
                    opt.classList.remove('active');
                });

                // Add active class to selected option
                this.classList.add('active');

                // Load data for selected travel
                currentTravelId = parseInt(this.getAttribute('data-travel-id'));
                loadTravelData(currentTravelId);
            });

            travelOptionsContainer.appendChild(option);
        });

        return panel;
    }

    // Inicjalizacja wizualizacji
    function initVisualization() {
        const container = document.getElementById('visualization');
        width = container.clientWidth;
        height = container.clientHeight;

        // Inicjalizacja tooltip
        tooltip = d3.select("#tooltip");

        // Inicjalizacja zoom
        zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        // Tworzymy SVG
        svg = d3.select("#visualization")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .call(zoom);

        // Grupa do której będziemy dodawać elementy
        g = svg.append("g");

        // Dodajemy obsługę przycisków i innych interakcji
        setupInteractions();

        // Create floating panels
        createTravelPanel();
        createStatsPanel();

        // Hide the statistics section in the sidebar
        document.querySelector('.statistics').style.display = 'none';

        // Ładujemy dane dla domyślnej podróży
        loadTravelData(currentTravelId);
    }

    // Ładowanie danych JSON dla wybranej podróży
    async function loadTravelData(travelId) {
        // Pokaż wskaźnik ładowania
        const loadingIndicator = document.getElementById('loadingIndicator');
        loadingIndicator.style.display = 'block';

        try {
            // Make sure travelsConfig exists
            if (!window.travelsConfig || !Array.isArray(window.travelsConfig)) {
                throw new Error("Konfiguracja podróży niedostępna. Upewnij się, że plik travels.js jest poprawnie załadowany.");
            }

            // Znajdź konfigurację podróży
            const travel = window.travelsConfig.find(t => t.id === travelId);
            if (!travel) {
                throw new Error(`Podróż o ID ${travelId} nie została znaleziona.`);
            }

            // Aktualizuj tytuł strony i nagłówek
            document.title = `Drzewko Wyborów - ${travel.name}`;
            document.getElementById('travelTitle').textContent = `Drzewko Wyborów - ${travel.name}`;

            // Resetujemy dane scen
            scenesData = {};

            // Defensive check for travel files
            if (!travel.files || !Array.isArray(travel.files) || travel.files.length === 0) {
                throw new Error(`Brak plików do załadowania dla podróży "${travel.name}"`);
            }

            // Ładujemy wszystkie pliki JSON dla wybranej podróży
            for (const file of travel.files) {
                try {
                    const response = await fetch(`${travel.path}/${file}`);
                    if (!response.ok) {
                        throw new Error(`Błąd ładowania pliku ${file}: ${response.status}`);
                    }

                    // Pobierz tekst i usuń komentarze
                    const text = await response.text();
                    const cleanedText = text.replace(/\/\/.*$/gm, '');

                    try {
                        // Parsuj oczyszczony tekst jako JSON
                        const fileData = JSON.parse(cleanedText);

                        // Dodaj do głównego obiektu scen z prefiksem
                        Object.keys(fileData).forEach(sceneId => {
                            const prefixedSceneId = `travel${travelId}_${sceneId}`;
                            const scene = { ...fileData[sceneId] };

                            // Aktualizacja odniesień w wyborach
                            if (scene.choices && scene.choices.length > 0) {
                                scene.choices = scene.choices.map(choice => {
                                    return {
                                        ...choice,
                                        nextScene: `travel${travelId}_${choice.nextScene}`
                                    };
                                });
                            }

                            scenesData[prefixedSceneId] = scene;
                        });
                    } catch (parseError) {
                        console.error(`Błąd parsowania pliku ${file}:`, parseError);
                        throw new Error(`Błąd parsowania pliku ${file}: ${parseError.message}`);
                    }
                } catch (fetchError) {
                    console.error(`Błąd pobierania pliku ${file}:`, fetchError);
                    throw new Error(`Błąd pobierania pliku ${file}: ${fetchError.message}`);
                }
            }

            // Verify that scenesData has content
            if (Object.keys(scenesData).length === 0) {
                throw new Error("Nie załadowano żadnych danych scen. Sprawdź pliki JSON.");
            }

            // Przetwórz dane i renderuj graf
            root = processData(currentLayout);

            // Wykrywamy martwe końce i połączenia między ścieżkami
            detectDeadEnds(root);
            detectCrossPathLinks(root);

            // Obliczamy statystyki
            calculateStatistics(root);

            // Renderujemy drzewo
            renderGraph();

            // Wyświetlamy informacje o scenie początkowej
            displaySceneInfo(`travel${travelId}_intro`);

            // Zaznaczamy węzeł początkowy jako wybrany
            d3.selectAll(".node").filter(d => d.data.id === `travel${travelId}_intro`).classed("selected", true);

            // Resetujemy widok
            resetView();

            // Update travel options in both panels
            updateTravelSelectors();

            console.log(`Podróż ${travel.name} (ID: ${travelId}) załadowana pomyślnie.`);
        } catch (error) {
            console.error(`Błąd podczas ładowania danych podróży:`, error);
            // Wyświetl informację o błędzie
            const infoPanel = document.querySelector('.scene-info');
            infoPanel.innerHTML = `
                <h3 style="color: #ef4444;">⚠️ Błąd ładowania</h3>
                <div class="quote" style="color: #ef4444; background-color: rgba(239, 68, 68, 0.1); border-left-color: #ef4444;">
                    "Nie udało się załadować danych dla wybranej podróży. Sprawdź czy pliki JSON istnieją w podanej ścieżce."
                </div>
                <div class="text" style="margin-top: 15px; padding: 10px; background-color: rgba(239, 68, 68, 0.05); border-radius: 4px;">
                    <strong>Błąd:</strong> ${error.message}
                </div>
            `;
        } finally {
            // Ukryj wskaźnik ładowania
            loadingIndicator.style.display = 'none';
        }
    }

    // Update travel selectors in both sidebar and floating panel
    function updateTravelSelectors() {
        // Update travel options in floating panel
        const floatingOptions = document.querySelectorAll('#floating-travel-options .travel-option');
        floatingOptions.forEach(option => {
            const travelId = parseInt(option.getAttribute('data-travel-id'));
            if (travelId === currentTravelId) {
                option.classList.add('active');
            } else {
                option.classList.remove('active');
            }
        });
    }

    // Przetwarzanie danych do formatu hierarchicznego
    function processData(layoutType) {
        // Tworzymy funkcję do identyfikacji węzłów
        const stratify = d3.stratify()
            .id(d => d.id)
            .parentId(d => d.parentId);

        // Przygotowujemy dane
        const flatData = [];
        const processedNodes = new Set();
        const processedEdges = new Set();
        crossPathLinks = []; // Reset cross path links

        // Funkcja pomocnicza do przetwarzania scen
        function processScene(sceneId, parentId = null, depth = 0, pathId = null) {
            // Jeśli nie podano pathId, używamy sceneId jako ID ścieżki
            if (pathId === null) {
                pathId = sceneId;
            }

            // Sprawdzamy, czy scena istnieje
            if (!scenesData[sceneId]) {
                console.warn(`Scena nie znaleziona: ${sceneId}`);

                // Dodajemy informację o martwym końcu
                flatData.push({
                    id: `deadend-${parentId}-${sceneId}`,
                    parentId: parentId,
                    name: sceneId,
                    nodeType: 'deadEnd',
                    depth,
                    isDeadEnd: true,
                    pathId
                });
                return;
            }

            const scene = scenesData[sceneId];

            // Określamy typ sceny
            let nodeType = 'normal';
            if (sceneId.endsWith('_intro')) {
                nodeType = 'start';
            } else if (!scene.choices || scene.choices.length === 0 ||
                (scene.choices.length === 1 && scene.choices[0].nextScene.endsWith('_intro'))) {
                nodeType = 'end';
            }

            // Tworzymy unikalny identyfikator krawędzi
            const edgeId = parentId ? `${parentId}->${sceneId}` : null;

            // Sprawdzamy, czy ta krawędź już została przetworzona
            if (parentId && processedEdges.has(edgeId)) {
                return;
            }

            // Zaznaczamy krawędź jako przetworzoną
            if (edgeId) {
                processedEdges.add(edgeId);
            }

            // Jeśli scena już istnieje i ma rodzica, sprawdzamy czy trzeba dodać wirtualny węzeł
            // lub zapisać informację o połączeniu między ścieżkami
            if (processedNodes.has(sceneId) && parentId) {
                // Pobierz istniejący węzeł
                const existingNode = flatData.find(d => d.id === sceneId);

                // Sprawdź czy węzeł należy do innej ścieżki
                if (existingNode && existingNode.pathId !== pathId) {
                    // Dodaj wirtualny węzeł dla lepszego renderowania
                    const virtualNodeId = `virtual-${parentId}-${sceneId}`;
                    flatData.push({
                        id: virtualNodeId,
                        parentId: parentId,
                        name: sceneId,
                        isVirtual: true,
                        targetScene: sceneId,
                        nodeType,
                        pathId,
                        crossPath: true
                    });
                } else {
                    // Jeśli jest w tej samej ścieżce, dodaj standardowy wirtualny węzeł
                    const virtualNodeId = `virtual-${parentId}-${sceneId}`;
                    flatData.push({
                        id: virtualNodeId,
                        parentId: parentId,
                        name: sceneId,
                        isVirtual: true,
                        targetScene: sceneId,
                        nodeType,
                        pathId
                    });
                }
                return;
            }

            // Dodajemy scenę do przetworzonych
            processedNodes.add(sceneId);

            // Dodajemy węzeł do danych
            flatData.push({
                id: sceneId,
                parentId: parentId,
                name: sceneId,
                scene: scene,
                nodeType,
                depth,
                pathId
            });

            // Przetwarzamy wszystkie wybory
            if (scene.choices && scene.choices.length > 0) {
                scene.choices.forEach((choice, i) => {
                    const nextSceneId = choice.nextScene;
                    // Zapisujemy tekst wyboru
                    flatData.find(d => d.id === sceneId).choices =
                        flatData.find(d => d.id === sceneId).choices || [];
                    flatData.find(d => d.id === sceneId).choices[i] = choice.text;

                    // Przetwarzamy następną scenę
                    processScene(nextSceneId, sceneId, depth + 1, pathId);
                });
            }
        }

        // Zaczynamy od sceny "intro" dla aktualnej podróży
        processScene(`travel${currentTravelId}_intro`);

        // Tworzymy hierarchię
        const hierarchy = stratify(flatData);

        // Wybieramy odpowiedni layout
        let layout;
        switch (layoutType) {
            case 'tree':
                layout = d3.tree().size([height - 80, width - 100]);
                break;
            case 'cluster':
                layout = d3.cluster().size([height - 80, width - 100]);
                break;
            case 'radial':
                // Dla układu radialnego używamy mniejszy promień, aby zmieścić graf
                const radius = Math.min(width, height) / 2 - 80;
                layout = d3.cluster()
                    .size([2 * Math.PI, radius])
                    .separation((a, b) => (a.parent == b.parent ? 1 : 2) / a.depth);
                break;
            default:
                layout = d3.tree().size([height - 80, width - 100]);
        }

        // Aplikujemy układ do hierarchii
        return layout(hierarchy);
    }

    // Wykrywanie martwych końców
    function detectDeadEnds(root) {
        let deadEnds = [];

        root.eachAfter(node => {
            if (node.data.isDeadEnd) {
                node.data.nodeType = 'deadEnd';
                deadEnds.push(node);

                // Dodajemy dodatkową przestrzeń wokół martwych końców dla lepszej widoczności
                if (node.parent && node.parent.children && node.parent.children.length > 1) {
                    // Znajdujemy indeks bieżącego węzła w dzieciach rodzica
                    const index = node.parent.children.indexOf(node);

                    // Dodajemy małe przesunięcie dla sąsiednich węzłów dla lepszej widoczności
                    if (index > 0) {
                        // Przesuwamy poprzedni węzeł nieco w lewo
                        const prevNode = node.parent.children[index - 1];
                        if (currentLayout === 'radial') {
                            prevNode.x -= 0.1; // Małe przesunięcie kątowe
                        } else {
                            prevNode.x -= 10; // Przesunięcie w pikselach
                        }
                    }

                    if (index < node.parent.children.length - 1) {
                        // Przesuwamy następny węzeł nieco w prawo
                        const nextNode = node.parent.children[index + 1];
                        if (currentLayout === 'radial') {
                            nextNode.x += 0.1; // Małe przesunięcie kątowe
                        } else {
                            nextNode.x += 10; // Przesunięcie w pikselach
                        }
                    }
                }
            }
        });

        return deadEnds;
    }

    // Wykrywanie i przygotowanie danych o połączeniach między ścieżkami
    function detectCrossPathLinks(root) {
        // Use our comprehensive detection method instead
        detectAllCrossPaths();
    }

    // Renderowanie grafu
    function renderGraph() {
        // Clear the canvas
        g.selectAll("*").remove();

        // Add arrow marker for cross-path connections
        addArrowMarker();

        // Set appropriate transformations for different layouts
        if (currentLayout === 'radial') {
            g.attr("transform", `translate(${width/2},${height/2})`);
        } else {
            g.attr("transform", `translate(50,40)`);
        }

        // Create appropriate link generator
        let linkGenerator;
        if (currentLayout === 'radial') {
            linkGenerator = d3.linkRadial()
                .angle(d => d.x)
                .radius(d => d.y);
        } else {
            linkGenerator = d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x);
        }

        // Draw regular tree links
        g.selectAll(".link")
            .data(root.links())
            .enter()
            .append("path")
            .attr("class", "link")
            .attr("d", linkGenerator);

        // Draw nodes
        const nodes = g.selectAll(".node")
            .data(root.descendants())
            .enter()
            .append("g")
            .attr("class", d => {
                let classes = "node";
                if (d.data.isDeadEnd) classes += " dead-end";
                return classes;
            })
            .attr("transform", d => {
                if (currentLayout === 'radial') {
                    const x = Math.sin(d.x) * d.y;
                    const y = -Math.cos(d.x) * d.y;
                    return `translate(${x},${y})`;
                } else {
                    return `translate(${d.y},${d.x})`;
                }
            })
            .on("click", function(event, d) {
                // Clear previous selection
                d3.selectAll(".node").classed("selected", false);

                // Mark this node as selected
                d3.select(this).classed("selected", true);
                selectedNode = d;

                // Display scene info
                const sceneId = d.data.isVirtual ? d.data.targetScene : d.data.id;
                displaySceneInfo(sceneId);
            })
            .on("mouseover", function(event, d) {
                event.stopPropagation();

                d3.select(this).classed("hover", true);

                d3.select(this).select("circle")
                    .transition().duration(200)
                    .attr("r", nodeRadius * 1.3);

                showTooltip(event, d);

                if (labelMode === 'hover') {
                    d3.select(this).select("text").style("opacity", 1);
                }
            })
            .on("mouseout", function() {
                d3.select(this).classed("hover", false);

                d3.select(this).select("circle")
                    .transition().duration(200)
                    .attr("r", nodeRadius);

                tooltip.style("opacity", 0);

                if (labelMode === 'hover') {
                    d3.select(this).select("text").style("opacity", 0);
                }
            });

        // Add circles for nodes
        nodes.append("circle")
            .attr("r", nodeRadius)
            .attr("fill", d => {
                if (d.data.isDeadEnd) return nodeColors.deadEnd;

                const sceneId = d.data.isVirtual ? d.data.targetScene : d.data.id;
                const nodeType = d.data.nodeType;
                return nodeColors[nodeType];
            })
            .attr("stroke", d => d.data.isDeadEnd ? "#ef4444" : "#d1d5db")
            .attr("stroke-width", d => d.data.isDeadEnd ? 3 : 2);

        // Add X marks for dead ends
        nodes.filter(d => d.data.isDeadEnd)
            .append("g")
            .attr("class", "node-x")
            .call(g => {
                g.append("circle")
                    .attr("r", nodeRadius * 0.9)
                    .attr("fill", "#fff")
                    .attr("stroke", "#ef4444")
                    .attr("stroke-width", 1);

                g.append("line")
                    .attr("x1", -nodeRadius/1.2)
                    .attr("y1", -nodeRadius/1.2)
                    .attr("x2", nodeRadius/1.2)
                    .attr("y2", nodeRadius/1.2)
                    .attr("stroke", "#ef4444")
                    .attr("stroke-width", 3)
                    .attr("stroke-linecap", "round");

                g.append("line")
                    .attr("x1", nodeRadius/1.2)
                    .attr("y1", -nodeRadius/1.2)
                    .attr("x2", -nodeRadius/1.2)
                    .attr("y2", nodeRadius/1.2)
                    .attr("stroke", "#ef4444")
                    .attr("stroke-width", 3)
                    .attr("stroke-linecap", "round");
            });

        // Add backgrounds for labels
        nodes.append("rect")
            .attr("class", "label-background")
            .attr("x", -25)
            .attr("y", -25)
            .attr("width", 50)
            .attr("height", 20)
            .attr("opacity", 0);

        // Add node labels
        nodes.append("text")
            .attr("dy", -15)
            .attr("x", 0)
            .text(d => {
                let name;
                if (d.data.isDeadEnd) {
                    return "Brak sceny!";
                } else {
                    name = d.data.isVirtual ? d.data.targetScene : d.data.id;
                    name = name.replace(/^travel\d+_/, '');
                }
                return name.length > 10 ? name.substring(0, 8) + '..' : name;
            })
            .style("opacity", labelMode === 'visible' ? 1 : 0);

        // Update mode indicator
        document.querySelector('.mode-indicator').textContent =
            `Tryb: ${currentLayout.charAt(0).toUpperCase() + currentLayout.slice(1)}`;

        // Render cross-path connections
        renderCrossPathLinks();
    }

    // Całkowicie przepisana funkcja wyświetlania tooltipa
    function showTooltip(event, d) {
        // Podstawowe informacje o scenie
        const sceneId = d.data.isVirtual ? d.data.targetScene : d.data.id;
        const scene = d.data.isDeadEnd ? null : scenesData[sceneId];

        // Ustawienie treści tooltipa
        let title = d.data.isDeadEnd ? "Brak sceny!" : sceneId.replace(/^travel\d+_/, '');
        tooltip.select(".tooltip-title").text(title);

        if (d.data.isDeadEnd) {
            tooltip.select(".tooltip-quote").text("Ta ścieżka prowadzi do nieistniejącej sceny.")
                .style("display", "block")
                .style("color", "#ef4444");
        } else if (scene && scene.quote) {
            tooltip.select(".tooltip-quote").text(`"${scene.quote}"`)
                .style("display", "block")
                .style("color", "#6b7280");
        } else {
            tooltip.select(".tooltip-quote").style("display", "none");
        }

        // Pobieramy pozycję kursora
        const mouseX = event.clientX;
        const mouseY = event.clientY;

        // Stała szerokość tooltipa
        const tooltipWidth = 280;

        // Granice widocznego obszaru okna
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Domyślne położenie - po prawej stronie kursora
        let xPos = mouseX + 10;
        let yPos = mouseY + 10;

        // Sprawdzamy czy tooltip wyjdzie poza prawą krawędź
        if (xPos + tooltipWidth > viewportWidth) {
            xPos = Math.max(0, mouseX - tooltipWidth - 10); // umieść po lewej stronie kursora
        }

        // Sprawdzamy czy tooltip wyjdzie poza dolną krawędź
        // Najpierw ustawiamy tooltip, aby poznać jego wysokość
        tooltip.style("left", "0px").style("top", "0px").style("opacity", "0");
        const tooltipHeight = tooltip.node().getBoundingClientRect().height;

        if (yPos + tooltipHeight > viewportHeight) {
            yPos = Math.max(0, mouseY - tooltipHeight - 10); // umieść nad kursorem
        }

        // Ustawiamy tooltip w finalnej pozycji
        tooltip
            .style("left", xPos + "px")
            .style("top", yPos + "px")
            .style("opacity", 1);
    }

    // Wyświetlanie informacji o scenie
    function displaySceneInfo(sceneId) {
        const scene = scenesData[sceneId];
        if (!scene) {
            // Obsługa martwego końca lub nieistniejącej sceny
            const infoPanel = document.querySelector('.scene-info');
            infoPanel.innerHTML = `
                <h3 style="color: #ef4444;">⚠️ Brak sceny: ${sceneId.replace(/^travel\d+_/, '')}</h3>
                <div class="quote" style="color: #ef4444; background-color: rgba(239, 68, 68, 0.1); border-left-color: #ef4444;">
                    "Ta scena nie istnieje w bazie danych. To martwy koniec w drzewie wyborów."
                </div>
                <div class="text" style="margin-top: 15px; padding: 10px; background-color: rgba(239, 68, 68, 0.05); border-radius: 4px;">
                    <strong>Problem:</strong> Ta ścieżka prowadzi do nieistniejącej sceny.<br><br>
                    <strong>Rozwiązanie:</strong> Należy dodać tę scenę do pliku JSON lub poprawić referencję do niej.
                </div>
            `;
            return;
        }

        const infoPanel = document.querySelector('.scene-info');
        const sceneName = sceneId.replace(/^travel\d+_/, '');

        let html = `<h3>Scena: ${sceneName}</h3>`;

        if (scene.quote) {
            html += `<div class="quote">"${scene.quote}"</div>`;
        }

        if (scene.text) {
            // Pokazujemy pełny tekst, pozwalając na scroll
            const textWithoutTags = scene.text.replace(/<\/?[^>]+(>|$)/g, "");
            html += `<div class="text">${textWithoutTags}</div>`;
        }

        if (scene.choices && scene.choices.length > 0) {
            html += `<div class="choices"><h4>Wybory:</h4>`;
            scene.choices.forEach(choice => {
                // Usuwamy prefix podróży dla czytelności
                const nextScene = choice.nextScene.replace(/^travel\d+_/, '');
                html += `<div class="choice-item" data-scene="${choice.nextScene}">${choice.text} → <strong>${nextScene}</strong></div>`;
            });
            html += `</div>`;
        } else {
            html += `<div><em>Scena końcowa lub powrót do początku</em></div>`;
        }

        infoPanel.innerHTML = html;

        // Przewijanie do początku panelu informacyjnego
        const infoContainer = document.querySelector('.scene-info-container');
        infoContainer.scrollTop = 0;

        // Obsługa kliknięcia na wybory
        document.querySelectorAll('.choice-item').forEach(item => {
            item.addEventListener('click', function() {
                const nextSceneId = this.getAttribute('data-scene');
                focusOnScene(nextSceneId);
                displaySceneInfo(nextSceneId);
            });
        });
    }

    // Fokusowanie na konkretnej scenie
    function focusOnScene(sceneId) {
        // Najpierw szukamy węzła bezpośrednio o danym id
        let node = root.descendants().find(d => d.data.id === sceneId);

        // Jeśli nie znaleziono bezpośrednio, szukamy wirtualnych węzłów wskazujących na tę scenę
        if (!node) {
            node = root.descendants().find(d =>
                d.data.isVirtual && d.data.targetScene === sceneId
            );
        }

        // Jeśli nadal nie znaleziono, szukamy martwych końców związanych z tą sceną
        if (!node) {
            node = root.descendants().find(d =>
                d.data.isDeadEnd && d.data.name === sceneId
            );
        }

        if (node) {
            // Usuń poprzednie zaznaczenie
            d3.selectAll(".node").classed("selected", false);

            // Zaznacz znaleziony węzeł
            d3.selectAll(".node").filter(d => d === node).classed("selected", true);
            selectedNode = node;

            let transform;

            if (currentLayout === 'radial') {
                // Dla układu radialnego
                const x = Math.sin(node.x) * node.y;
                const y = -Math.cos(node.x) * node.y;
                transform = d3.zoomIdentity
                    .translate(width/2 - x, height/2 - y)
                    .scale(1.2);
            } else {
                // Dla układu drzewa i klastra
                transform = d3.zoomIdentity
                    .translate(width/2 - node.y, height/2 - node.x)
                    .scale(1.2);
            }

            svg.transition().duration(750).call(zoom.transform, transform);
        }
    }

    // Obliczanie statystyk
    function calculateStatistics(root) {
        // Unikalne sceny (bez wirtualnych)
        const uniqueScenes = new Set();
        root.descendants().forEach(d => {
            if (!d.data.isVirtual && !d.data.isDeadEnd) {
                uniqueScenes.add(d.data.id);
            }
        });

        const totalScenes = uniqueScenes.size;

        // Liczba wyborów
        let totalChoices = 0;
        Object.values(scenesData).forEach(scene => {
            if (scene.choices) {
                totalChoices += scene.choices.length;
            }
        });

        // Liczba scen końcowych
        const endScenes = root.descendants()
            .filter(d => !d.data.isVirtual && !d.data.isDeadEnd && d.data.nodeType === 'end')
            .length;

        // Liczba martwych końców
        const deadEnds = root.descendants()
            .filter(d => d.data.isDeadEnd)
            .length;

        // Liczba połączeń między ścieżkami
        const crossPathsCount = crossPathLinks.length;

        // Aktualizujemy statystyki w interfejsie
        document.getElementById('totalScenes').textContent = totalScenes;
        document.getElementById('totalChoices').textContent = totalChoices;
        document.getElementById('endScenes').textContent = endScenes;
        document.getElementById('deadEnds').textContent = deadEnds;
        document.getElementById('crossPathLinks').textContent = crossPathsCount;

        // Update stats panel if it exists
        if (document.getElementById('totalScenes-panel')) {
            document.getElementById('totalScenes-panel').textContent = totalScenes;
            document.getElementById('totalChoices-panel').textContent = totalChoices;
            document.getElementById('endScenes-panel').textContent = endScenes;
            document.getElementById('deadEnds-panel').textContent = deadEnds;
            document.getElementById('crossPathLinks-panel').textContent = crossPathsCount;
        }
    }

    // Konfiguracja interakcji
    function setupInteractions() {
        // Przycisk powiększania
        document.getElementById('zoomIn').addEventListener('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 1.3);
        });

        // Przycisk pomniejszania
        document.getElementById('zoomOut').addEventListener('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 0.7);
        });

        // Przycisk resetowania widoku
        document.getElementById('resetView').addEventListener('click', resetView);

        // Przycisk powrotu do początku
        document.getElementById('focusIntro').addEventListener('click', () => {
            focusOnScene(`travel${currentTravelId}_intro`);
            displaySceneInfo(`travel${currentTravelId}_intro`);
        });

        // Obsługa wyszukiwania
        document.getElementById('searchInput').addEventListener('input', function() {
            const query = this.value.toLowerCase();
            if (query.length < 2) {
                // Przywracamy normalny widok
                d3.selectAll(".node circle")
                    .attr("r", nodeRadius)
                    .attr("opacity", 1);
                return;
            }

            // Wyszukujemy pasujące węzły
            const nodes = d3.selectAll(".node");
            nodes.each(function(d) {
                const sceneName = d.data.id.replace(/^travel\d+_/, '').toLowerCase();
                const isMatch = sceneName.includes(query);

                // Podświetlamy pasujące węzły
                d3.select(this).select("circle")
                    .transition()
                    .duration(300)
                    .attr("r", isMatch ? nodeRadius * 1.5 : nodeRadius)
                    .attr("opacity", isMatch ? 1 : 0.3);
            });

            // Znajdujemy pierwszy pasujący węzeł
            const matchingNode = root.descendants().find(d =>
                d.data.id.replace(/^travel\d+_/, '').toLowerCase().includes(query)
            );

            if (matchingNode) {
                focusOnScene(matchingNode.data.id);
            }
        });

        // Obsługa zmiany layoutu
        document.querySelectorAll('.layout-option').forEach(option => {
            option.addEventListener('click', function() {
                // Usuwamy klasę active z wszystkich opcji
                document.querySelectorAll('.layout-option').forEach(o => {
                    o.classList.remove('active');
                });

                // Dodajemy klasę active do wybranej opcji
                this.classList.add('active');

                // Zmieniamy layout
                currentLayout = this.getAttribute('data-layout');

                // Przetwarzamy dane na nowo z nowym layoutem
                root = processData(currentLayout);

                // Wykrywamy martwe końce i połączenia między ścieżkami
                detectDeadEnds(root);
                detectCrossPathLinks(root);

                // Renderujemy graf na nowo
                renderGraph();

                // Resetujemy widok
                resetView();
            });
        });

        // Obsługa podwójnego kliknięcia na węzeł (przełączanie etykiet)
        svg.on("dblclick", function(event) {
            // Zatrzymujemy domyślne zachowanie (zoom)
            if (event) event.preventDefault();

            // Zmieniamy tryb etykiet
            if (labelMode === 'tooltip') {
                labelMode = 'visible';
                d3.selectAll(".node text").style("opacity", 1);
                d3.selectAll(".label-background").style("opacity", 0.7);
            } else if (labelMode === 'visible') {
                labelMode = 'hover';
                d3.selectAll(".node text").style("opacity", 0);
                d3.selectAll(".label-background").style("opacity", 0);
            } else {
                labelMode = 'tooltip';
                d3.selectAll(".node text").style("opacity", 0);
                d3.selectAll(".label-background").style("opacity", 0);
            }
        });

        // Obsługa klawiatury - strzałki do nawigacji
        document.addEventListener('keydown', function(event) {
            if (!selectedNode) return;

            let nextNode = null;

            // Znajdź sąsiednie węzły
            if (event.key === 'ArrowUp') {
                // Znajdź poprzedni węzeł (rodzic)
                nextNode = selectedNode.parent;
            } else if (event.key === 'ArrowDown') {
                // Znajdź pierwszy węzeł dziecko
                nextNode = selectedNode.children ? selectedNode.children[0] : null;
            } else if (event.key === 'ArrowLeft') {
                // Znajdź poprzedni węzeł na tym samym poziomie
                if (selectedNode.parent) {
                    const siblings = selectedNode.parent.children;
                    const currentIndex = siblings.indexOf(selectedNode);
                    if (currentIndex > 0) {
                        nextNode = siblings[currentIndex - 1];
                    }
                }
            } else if (event.key === 'ArrowRight') {
                // Znajdź następny węzeł na tym samym poziomie
                if (selectedNode.parent) {
                    const siblings = selectedNode.parent.children;
                    const currentIndex = siblings.indexOf(selectedNode);
                    if (currentIndex < siblings.length - 1) {
                        nextNode = siblings[currentIndex + 1];
                    }
                }
            }

            if (nextNode) {
                // Zaznacz nowy węzeł
                d3.selectAll(".node").classed("selected", false);
                d3.selectAll(".node").filter(d => d === nextNode).classed("selected", true);
                selectedNode = nextNode;

                // Pokaż informacje o scenie
                const sceneId = nextNode.data.isVirtual ? nextNode.data.targetScene : nextNode.data.id;
                displaySceneInfo(sceneId);

                // Przewiń widok do nowego węzła
                focusOnScene(sceneId);

                // Zapobiegaj domyślnej akcji przeglądarki (przewijanie strony)
                event.preventDefault();
            }
        });
    }

    // Resetowanie widoku
    function resetView() {
        if (currentLayout === 'radial') {
            // Dla układu radialnego, centrujemy graf
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(width/2, height/2)
                    .scale(0.9));
        } else {
            // Dla innych układów
            const bounds = g.node().getBBox();
            const fullWidth = bounds.width + 100;
            const fullHeight = bounds.height + 80;

            const scale = 0.9 / Math.max(fullWidth / width, fullHeight / height);
            const translateX = width / 2 - scale * (bounds.x + fullWidth / 2);
            const translateY = height / 2 - scale * (bounds.y + fullHeight / 2);

            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale));
        }
    }

    // Inicjalizacja po załadowaniu strony
    window.addEventListener('DOMContentLoaded', () => {
        initVisualization();
    });
</script>
</body>
</html>